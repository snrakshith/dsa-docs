<!doctype html>
<html lang="en" data-bs-theme="auto">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><link rel="preload" href="http://localhost:1313/fonts/vendor/jost/jost-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="http://localhost:1313/fonts/vendor/jost/jost-v4-latin-500.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="http://localhost:1313/fonts/vendor/jost/jost-v4-latin-700.woff2" as="font" type="font/woff2" crossorigin>
<script 
  src="/js/color-mode.f14b3e296de1d0b69e75af684b62a4a912a2cadab04e36123407cd8388204f1d.js"
  integrity="sha256-8Us&#43;KW3h0Laeda9oS2KkqRKiytqwTjYSNAfNg4ggTx0=">
</script>


<link rel="stylesheet" href="/main.01b0834d5af51b24812d02878d09c8d7677d6b8af13164fb50215889dc19aaefd0e9366c13b45a9a57ae481dfd1836bce46b5ebfe461d56e3498b9443d8c5e27.css" integrity="sha512-AbCDTVr1GySBLQKHjQnI12d9a4rxMWT7UCFYidwZqu/Q6TZsE7RamleuSB39GDa85Gtev&#43;Rh1W40mLlEPYxeJw==" crossorigin="anonymous">

<noscript><style>img.lazyload { display: none; }</style></noscript><base href="http://localhost:1313/es6/12-proxies-and-reflection/">
  <link rel="canonical" href="http://localhost:1313/es6/12-proxies-and-reflection/">
<title>12 Proxies and the Reflection API  |  DSA Prep</title>
<meta name="description" content="Congrats on setting up a new Doks project!">

    
    <link rel="icon" href="/favicon.ico" sizes="32x32">
    
      <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    
      <link
        rel="apple-touch-icon"
        href="/apple-touch-icon.png"
        sizes="180x180"
        type="image/png"
      >
      <link
        rel="icon"
        href="/favicon-192x192.png"
        sizes="192x192"
        type="image/png"
      >
      <link
        rel="icon"
        href="/favicon-512x512.png"
        sizes="512x512"
        type="image/png"
      >
<link rel="manifest" href="/manifest.webmanifest">

<meta property="og:title" content="12 Proxies and the Reflection API">
<meta property="og:description" content="ECMAScript 5 and ECMAScript 6 were both developed with demystifying JavaScript functionality in mind. For example, JavaScript environments contained nonenumerable and nonwritable object properties before ECMAScript 5, but developers couldn&rsquo;t define their own nonenumerable or nonwritable properties. ECMAScript 5 included the Object.defineProperty() method to allow developers to do what JavaScript engines could do already.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://localhost:1313/es6/12-proxies-and-reflection/"><meta property="og:image" content="http://localhost:1313/cover.png"><meta property="article:section" content="es6">

<meta property="og:site_name" content="Frontend documentation site">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/cover.png"><meta name="twitter:title" content="12 Proxies and the Reflection API">
<meta name="twitter:description" content="ECMAScript 5 and ECMAScript 6 were both developed with demystifying JavaScript functionality in mind. For example, JavaScript environments contained nonenumerable and nonwritable object properties before ECMAScript 5, but developers couldn&rsquo;t define their own nonenumerable or nonwritable properties. ECMAScript 5 included the Object.defineProperty() method to allow developers to do what JavaScript engines could do already.">
<meta name="twitter:site" content="@getdoks">

    
    <script type="application/ld+json">
  {
   "@context": "https://schema.org",
   "@type": "BreadcrumbList",
   "itemListElement": [
     {
       "@type": "ListItem",
       "item": "http://localhost:1313/",
       "name": "Preperation Sheet",
       "position": 1
     },
     {
       "@type": "ListItem",
       "item": "http://localhost:1313/es6/",
       "name": "Es6",
       "position": 2
     },
     {
       "@type": "ListItem",
       "name": "12 Proxies and the Reflection API",
       "position": 3
     }
   ]
 }
</script>





</head>

  
  <body class="single section es6" data-bs-spy="scroll" data-bs-target="#toc" data-bs-root-margin="0px 0px -60%" data-bs-smooth-scroll="true" tabindex="0">
    <div class="sticky-top">
<header class="navbar navbar-expand-lg">
  <div class="container-lg">
  
    <a class="navbar-brand me-auto me-lg-3" href="/">DSA Prep</a>

    
    
    <button type="button" id="searchToggleMobile" class="btn btn-link nav-link mx-2 d-lg-none" aria-label="Search website">
      <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <circle cx="10" cy="10" r="7"></circle>
        <line x1="21" y1="21" x2="15" y2="15"></line>
      </svg>
    </button>
    
    
    <button class="btn btn-link nav-link mx-2 order-3 d-lg-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasNavMain" aria-controls="offcanvasNavMain" aria-label="Open main navigation menu">
      <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-menu" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
        <line x1="4" y1="8" x2="20" y2="8"></line>
        <line x1="4" y1="16" x2="20" y2="16"></line>
      </svg>
    </button>

    
    <div class="offcanvas offcanvas-end h-auto" tabindex="-1" id="offcanvasNavMain" aria-labelledby="offcanvasNavMainLabel">
      <div class="offcanvas-header">
        <h5 class="offcanvas-title" id="offcanvasNavMainLabel">DSA Prep</h5>
        <button type="button" class="btn btn-link nav-link p-0 ms-auto" data-bs-dismiss="offcanvas" aria-label="Close">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-x" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
            <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
            <path d="M18 6l-12 12"></path>
            <path d="M6 6l12 12"></path>
         </svg>
        </button>
      </div>
      
      <div class="offcanvas-body d-flex flex-column flex-lg-row justify-content-between">
        <ul class="navbar-nav flex-grow-1"><li class="nav-item">
                <a class="nav-link" href="http://localhost:1313/code-snippets/">Code Snippets</a>
              </li>
            <li class="nav-item">
                <a class="nav-link" href="http://localhost:1313/es6/">ES6</a>
              </li>
            <li class="nav-item">
                <a class="nav-link" href="http://localhost:1313/others/">Others</a>
              </li>
            <li class="nav-item">
                <a class="nav-link" href="http://localhost:1313/resources/">Resources</a>
              </li>
            <li class="nav-item">
                <a class="nav-link" href="http://localhost:1313/prep-1/">Set 1</a>
              </li>
            </ul>

        
        
        <button type="button" id="searchToggleDesktop" class="btn btn-link nav-link p-2 d-none d-lg-block" aria-label="Search website">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
            <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
            <circle cx="10" cy="10" r="7"></circle>
            <line x1="21" y1="21" x2="15" y2="15"></line>
          </svg>
        </button>
        
        
        
        <button id="buttonColorMode" class="btn btn-link mx-auto nav-link p-0 ms-lg-2 me-lg-1" type="button" aria-label="Toggle theme">
          <svg data-bs-theme-value="dark" xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-moon" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
            <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
            <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
          </svg>
          <svg data-bs-theme-value="light" xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-sun" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
            <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
            <path d="M12 12m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0m-5 0h1m8 -9v1m8 8h1m-9 8v1m-6.4 -15.4l.7 .7m12.1 -.7l-.7 .7m0 11.4l.7 .7m-12.1 -.7l-.7 .7"></path>
          </svg>
        </button>
        
        <ul id="socialMenu" class="nav mx-auto flex-row order-lg-4">
          <li class="nav-item">
              <a class="nav-link social-link" href="https://github.com/snrakshith/dsa-docs"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path></svg><small class="ms-2 visually-hidden">GitHub</small></a>
            </li>
          </ul>
        
        </div>
    </div>

    
    </div>
</header>
</div>

<div class="modal" id="searchModal" tabindex="-1" aria-labelledby="searchModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-fullscreen-md-down">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5 visually-hidden" id="searchModalLabel">Search</h1>
        <button type="button" class="btn-close visually-hidden" data-bs-dismiss="modal" aria-label="Close"></button>
        <div class="search-input flex-grow-1 d-none">
          <form id="search-form" class="search-form" action="#" method="post" accept-charset="UTF-8" role="search">
            <label for="query" class="visually-hidden">Search</label>
            <div class="d-flex">
              <input type="search" id="query" name="query" class="search-text form-control form-control-lg" placeholder="Search" aria-label="Search" maxlength="128" autocomplete="off">
              <button type="button" class="btn btn-link text-decoration-none px-0 ms-3 d-md-none" data-bs-dismiss="modal" aria-label="Close">Cancel</button>
            </div>
          </form>
        </div>
      </div>
      <div class="modal-body">
        <p class="search-loading status message d-none mt-3 text-center">Loading search indexâ€¦</p>
        <p class="search-no-recent message d-none mt-3 text-center">No recent searches</p>
        <p class="search-no-results message d-none mt-3 text-center">No results for "<strong><span class="query-no-results">Query here</span></strong>"</p>
        <div id="searchResults" class="search-results"></div>
        <template>
          <article class="search-result list-view">
            <div class="card my-3">
              <div class="card-body">
                <header>
                  <h2 class="h5 title title-submitted mb-0"><a class="stretched-link text-decoration-none text-reset" href="#">Title here</a></h2>
                  <div class="submitted d-none"><time class="created-date">Date here</time></div>
                </header>
                <div class="content">Summary here</div>
              </div>
            </div>
          </article>
        </template>
      </div>
      <div class="modal-footer">
        <ul class="list-inline me-auto d-none d-md-block">
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Enter key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M12 3.53088v3c0 1-1 2-2 2H4M7 11.53088l-3-3 3-3"></path></g></svg></kbd><span class="DocSearch-Label">to select</span></li>
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Arrow down" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 3.5v8M10.5 8.5l-3 3-3-3"></path></g></svg></kbd><kbd class="me-2"><svg width="15" height="15" aria-label="Arrow up" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 11.5v-8M10.5 6.5l-3-3-3 3"></path></g></svg></kbd><span class="DocSearch-Label">to navigate</span></li>
          <li class="list-inline-item"><kbd class="me-2"><svg width="15" height="15" aria-label="Escape key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956"></path></g></svg></kbd><span class="DocSearch-Label">to close</span></li>
        </ul>
        <p class="d-md-none">Search by <a class="text-decoration-none" href="https://github.com/nextapps-de/flexsearch">FlexSearch</a></p>
      </div>
    </div>
  </div>
</div>


    <div class="wrap container-lg" role="document">
      <div class="content">
      
        
	<div class="row flex-xl-nowrap">
		
		<nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation">
			<div class="page-links">
  <h3>On this page</h3>
    <nav id="toc">
  <ul>
    <li><a href="#the-array-problem">The Array Problem</a></li>
    <li><a href="#what-are-proxies-and-reflection">What are Proxies and Reflection?</a></li>
    <li><a href="#creating-a-simple-proxy">Creating a Simple Proxy</a></li>
    <li><a href="#validating-properties-using-the-set-trap">Validating Properties Using the <code>set</code> Trap</a></li>
    <li><a href="#object-shape-validation-using-the-get-trap">Object Shape Validation Using the <code>get</code> Trap</a></li>
    <li><a href="#hiding-property-existence-using-the-has-trap">Hiding Property Existence Using the <code>has</code> Trap</a></li>
    <li><a href="#preventing-property-deletion-with-the-deleteproperty-trap">Preventing Property Deletion with the <code>deleteProperty</code> Trap</a></li>
    <li><a href="#prototype-proxy-traps">Prototype Proxy Traps</a>
      <ul>
        <li><a href="#how-prototype-proxy-traps-work">How Prototype Proxy Traps Work</a></li>
        <li><a href="#why-two-sets-of-methods">Why Two Sets of Methods?</a></li>
      </ul>
    </li>
    <li><a href="#object-extensibility-traps">Object Extensibility Traps</a>
      <ul>
        <li><a href="#two-basic-examples">Two Basic Examples</a></li>
        <li><a href="#duplicate-extensibility-methods">Duplicate Extensibility Methods</a></li>
      </ul>
    </li>
    <li><a href="#property-descriptor-traps">Property Descriptor Traps</a>
      <ul>
        <li><a href="#blocking-objectdefineproperty">Blocking Object.defineProperty()</a></li>
        <li><a href="#descriptor-object-restrictions">Descriptor Object Restrictions</a></li>
        <li><a href="#duplicate-descriptor-methods">Duplicate Descriptor Methods</a></li>
      </ul>
    </li>
    <li><a href="#the-ownkeys-trap">The <code>ownKeys</code> Trap</a></li>
    <li><a href="#function-proxies-with-the-apply-and-construct-traps">Function Proxies with the <code>apply</code> and <code>construct</code> Traps</a>
      <ul>
        <li><a href="#validating-function-parameters">Validating Function Parameters</a></li>
        <li><a href="#calling-constructors-without-new">Calling Constructors Without new</a></li>
        <li><a href="#overriding-abstract-base-class-constructors">Overriding Abstract Base Class Constructors</a></li>
        <li><a href="#callable-class-constructors">Callable Class Constructors</a></li>
      </ul>
    </li>
    <li><a href="#revocable-proxies">Revocable Proxies</a></li>
    <li><a href="#solving-the-array-problem">Solving the Array Problem</a>
      <ul>
        <li><a href="#detecting-array-indices">Detecting Array Indices</a></li>
        <li><a href="#increasing-length-when-adding-new-elements">Increasing length when Adding New Elements</a></li>
        <li><a href="#deleting-elements-on-reducing-length">Deleting Elements on Reducing length</a></li>
        <li><a href="#implementing-the-myarray-class">Implementing the MyArray Class</a></li>
      </ul>
    </li>
    <li><a href="#using-a-proxy-as-a-prototype">Using a Proxy as a Prototype</a>
      <ul>
        <li><a href="#using-the-get-trap-on-a-prototype">Using the <code>get</code> Trap on a Prototype</a></li>
        <li><a href="#using-the-set-trap-on-a-prototype">Using the <code>set</code> Trap on a Prototype</a></li>
        <li><a href="#using-the-has-trap-on-a-prototype">Using the <code>has</code> Trap on a Prototype</a></li>
        <li><a href="#proxies-as-prototypes-on-classes">Proxies as Prototypes on Classes</a></li>
      </ul>
    </li>
    <li><a href="#summary">Summary</a></li>
  </ul>
</nav>
</div>

		</nav>
		<main class="docs-content col-lg-11 col-xl-9 mx-xl-auto">
		
			<h1>12 Proxies and the Reflection API</h1>
			
			<nav class="toc-mobile d-xl-none" aria-label="Quaternary navigation">
				<details>
    <summary>On this page</summary>
    <div class="page-links">
      <nav id="TableOfContents">
  <ul>
    <li><a href="#the-array-problem">The Array Problem</a></li>
    <li><a href="#what-are-proxies-and-reflection">What are Proxies and Reflection?</a></li>
    <li><a href="#creating-a-simple-proxy">Creating a Simple Proxy</a></li>
    <li><a href="#validating-properties-using-the-set-trap">Validating Properties Using the <code>set</code> Trap</a></li>
    <li><a href="#object-shape-validation-using-the-get-trap">Object Shape Validation Using the <code>get</code> Trap</a></li>
    <li><a href="#hiding-property-existence-using-the-has-trap">Hiding Property Existence Using the <code>has</code> Trap</a></li>
    <li><a href="#preventing-property-deletion-with-the-deleteproperty-trap">Preventing Property Deletion with the <code>deleteProperty</code> Trap</a></li>
    <li><a href="#prototype-proxy-traps">Prototype Proxy Traps</a>
      <ul>
        <li><a href="#how-prototype-proxy-traps-work">How Prototype Proxy Traps Work</a></li>
        <li><a href="#why-two-sets-of-methods">Why Two Sets of Methods?</a></li>
      </ul>
    </li>
    <li><a href="#object-extensibility-traps">Object Extensibility Traps</a>
      <ul>
        <li><a href="#two-basic-examples">Two Basic Examples</a></li>
        <li><a href="#duplicate-extensibility-methods">Duplicate Extensibility Methods</a></li>
      </ul>
    </li>
    <li><a href="#property-descriptor-traps">Property Descriptor Traps</a>
      <ul>
        <li><a href="#blocking-objectdefineproperty">Blocking Object.defineProperty()</a></li>
        <li><a href="#descriptor-object-restrictions">Descriptor Object Restrictions</a></li>
        <li><a href="#duplicate-descriptor-methods">Duplicate Descriptor Methods</a></li>
      </ul>
    </li>
    <li><a href="#the-ownkeys-trap">The <code>ownKeys</code> Trap</a></li>
    <li><a href="#function-proxies-with-the-apply-and-construct-traps">Function Proxies with the <code>apply</code> and <code>construct</code> Traps</a>
      <ul>
        <li><a href="#validating-function-parameters">Validating Function Parameters</a></li>
        <li><a href="#calling-constructors-without-new">Calling Constructors Without new</a></li>
        <li><a href="#overriding-abstract-base-class-constructors">Overriding Abstract Base Class Constructors</a></li>
        <li><a href="#callable-class-constructors">Callable Class Constructors</a></li>
      </ul>
    </li>
    <li><a href="#revocable-proxies">Revocable Proxies</a></li>
    <li><a href="#solving-the-array-problem">Solving the Array Problem</a>
      <ul>
        <li><a href="#detecting-array-indices">Detecting Array Indices</a></li>
        <li><a href="#increasing-length-when-adding-new-elements">Increasing length when Adding New Elements</a></li>
        <li><a href="#deleting-elements-on-reducing-length">Deleting Elements on Reducing length</a></li>
        <li><a href="#implementing-the-myarray-class">Implementing the MyArray Class</a></li>
      </ul>
    </li>
    <li><a href="#using-a-proxy-as-a-prototype">Using a Proxy as a Prototype</a>
      <ul>
        <li><a href="#using-the-get-trap-on-a-prototype">Using the <code>get</code> Trap on a Prototype</a></li>
        <li><a href="#using-the-set-trap-on-a-prototype">Using the <code>set</code> Trap on a Prototype</a></li>
        <li><a href="#using-the-has-trap-on-a-prototype">Using the <code>has</code> Trap on a Prototype</a></li>
        <li><a href="#proxies-as-prototypes-on-classes">Proxies as Prototypes on Classes</a></li>
      </ul>
    </li>
    <li><a href="#summary">Summary</a></li>
  </ul>
</nav>
    </div>
  </details>

			</nav>
			<p>ECMAScript 5 and ECMAScript 6 were both developed with demystifying JavaScript functionality in mind. For example, JavaScript environments contained nonenumerable and nonwritable object properties before ECMAScript 5, but developers couldn&rsquo;t define their own nonenumerable or nonwritable properties. ECMAScript 5 included the <code>Object.defineProperty()</code> method to allow developers to do what JavaScript engines could do already.</p>
<p>ECMAScript 6 gives developers further access to JavaScript engine capabilities previously available only to built-in objects. The language exposes the inner workings of objects through <em>proxies</em>, which are wrappers that can intercept and alter low-level operations of the JavaScript engine. This chapter starts by describing the problem that proxies are meant to address in detail, and then discusses how you can create and use proxies effectively.</p>
<h2 id="the-array-problem">The Array Problem<a href="#the-array-problem" class="anchor" aria-hidden="true">#</a> </h2>
<p>The JavaScript array object behaves in ways that developers couldn&rsquo;t mimic in their own objects before ECMASCript 6. An array&rsquo;s <code>length</code> property is affected when you assign values to specific array items, and you can modify array items by modifying the <code>length</code> property. For example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;red&#34;</span><span class="p">,</span> <span class="s2">&#34;green&#34;</span><span class="p">,</span> <span class="s2">&#34;blue&#34;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;black&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span> <span class="c1">// &#34;black&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// &#34;green&#34;
</span></span></span></code></pre></div>
  </figure>
</div>
<p>The <code>colors</code> array starts with three items. Assigning <code>&quot;black&quot;</code> to <code>colors[3]</code> automatically increments the <code>length</code> property to <code>4</code>. Setting the <code>length</code> property to <code>2</code> removes the last two items in the array, leaving only the first two items. Nothing in ECMAScript 5 allows developers to achieve this behavior, but proxies change that.</p>
<p>I&gt; This nonstandard behavior is why arrays are considered exotic objects in ECMAScript 6.</p>
<h2 id="what-are-proxies-and-reflection">What are Proxies and Reflection?<a href="#what-are-proxies-and-reflection" class="anchor" aria-hidden="true">#</a> </h2>
<p>You can create a proxy to use in place of another object (called the <em>target</em>) by calling <code>new Proxy()</code>. The proxy <em>virtualizes</em> the target so that the proxy and the target appear to be the same object to functionality using the proxy.</p>
<p>Proxies allow you to intercept low-level object operations on the target that are otherwise internal to the JavaScript engine. These low-level operations are intercepted using a <em>trap</em>, which is a function that responds to a specific operation.</p>
<p>The reflection API, represented by the <code>Reflect</code> object, is a collection of methods that provide the default behavior for the same low-level operations that proxies can override. There is a <code>Reflect</code> method for every proxy trap. Those methods have the same name and are passed the same arguments as their respective proxy traps. Table 11-1 summarizes this behavior.</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">Proxy Trap</th>
          <th style="text-align: left">Overrides the Behavior Of</th>
          <th style="text-align: left">Default Behavior</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><code>get</code></td>
          <td style="text-align: left">Reading a property value</td>
          <td style="text-align: left"><code>Reflect.get()</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><code>set</code></td>
          <td style="text-align: left">Writing to a property</td>
          <td style="text-align: left"><code>Reflect.set()</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><code>has</code></td>
          <td style="text-align: left">The <code>in</code> operator</td>
          <td style="text-align: left"><code>Reflect.has()</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><code>deleteProperty</code></td>
          <td style="text-align: left">The <code>delete</code> operator</td>
          <td style="text-align: left"><code>Reflect.deleteProperty()</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><code>getPrototypeOf</code></td>
          <td style="text-align: left"><code>Object.getPrototypeOf()</code></td>
          <td style="text-align: left"><code>Reflect.getPrototypeOf()</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><code>setPrototypeOf</code></td>
          <td style="text-align: left"><code>Object.setPrototypeOf()</code></td>
          <td style="text-align: left"><code>Reflect.setPrototypeOf()</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><code>isExtensible</code></td>
          <td style="text-align: left"><code>Object.isExtensible()</code></td>
          <td style="text-align: left"><code>Reflect.isExtensible()</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><code>preventExtensions</code></td>
          <td style="text-align: left"><code>Object.preventExtensions()</code></td>
          <td style="text-align: left"><code>Reflect.preventExtensions()</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><code>getOwnPropertyDescriptor</code></td>
          <td style="text-align: left"><code>Object.getOwnPropertyDescriptor()</code></td>
          <td style="text-align: left"><code>Reflect.getOwnPropertyDescriptor()</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><code>defineProperty</code></td>
          <td style="text-align: left"><code>Object.defineProperty()</code></td>
          <td style="text-align: left"><code>Reflect.defineProperty</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><code>ownKeys</code></td>
          <td style="text-align: left"><code>Object.keys</code>, <code>Object.getOwnPropertyNames()</code>, <code>Object.getOwnPropertySymbols()</code></td>
          <td style="text-align: left"><code>Reflect.ownKeys()</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><code>apply</code></td>
          <td style="text-align: left">Calling a function</td>
          <td style="text-align: left"><code>Reflect.apply()</code></td>
      </tr>
      <tr>
          <td style="text-align: left"><code>construct</code></td>
          <td style="text-align: left">Calling a function with <code>new</code></td>
          <td style="text-align: left"><code>Reflect.construct()</code></td>
      </tr>
  </tbody>
</table>
<p>Each trap overrides some built-in behavior of JavaScript objects, allowing you to intercept and modify the behavior. If you still need to use the built-in behavior, then you can use the corresponding reflection API method. The relationship between proxies and the reflection API becomes clear when you start creating proxies, so it&rsquo;s best to dive in and look at some examples.</p>
<p>I&gt; The original ECMAScript 6 specification had an additional trap called <code>enumerate</code> that was designed to alter how <code>for-in</code> and <code>Object.keys()</code> enumerated properties on an object. However, the <code>enumerate</code> trap was removed in ECMAScript 7 (also called ECMAScript 2016) as difficulties were discovered during implementation. The <code>enumerate</code> trap no longer exists in any JavaScript environment and is therefore not covered in this chapter.</p>
<h2 id="creating-a-simple-proxy">Creating a Simple Proxy<a href="#creating-a-simple-proxy" class="anchor" aria-hidden="true">#</a> </h2>
<p>When you use the <code>Proxy</code> constructor to make a proxy, you&rsquo;ll pass it two arguments: the target and a handler. A <em>handler</em> is an object that defines one or more traps. The proxy uses the default behavior for all operations except when traps are defined for that operation. To create a simple forwarding proxy, you can use a handler without any traps:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;proxy&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;proxy&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;proxy&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">target</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;target&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;target&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;target&#34;
</span></span></span></code></pre></div>
  </figure>
</div>
<p>In this example, <code>proxy</code> forwards all operations directly to <code>target</code>. When <code>&quot;proxy&quot;</code> is assigned to the <code>proxy.name</code> property, <code>name</code> is created on <code>target</code>. The proxy itself is not storing this property; it&rsquo;s simply forwarding the operation to <code>target</code>. Similarly, the values of <code>proxy.name</code> and <code>target.name</code> are the same because they are both references to <code>target.name</code>. That also means setting <code>target.name</code> to a new value causes <code>proxy.name</code> to reflect the same change. Of course, proxies without traps aren&rsquo;t very interesting, so what happens when you define a trap?</p>
<h2 id="validating-properties-using-the-set-trap">Validating Properties Using the <code>set</code> Trap<a href="#validating-properties-using-the-set-trap" class="anchor" aria-hidden="true">#</a> </h2>
<p>Suppose you want to create an object whose property values must be numbers. That means every new property added to the object must be validated, and an error must be thrown if the value isn&rsquo;t a number. To accomplish this, you could define a <code>set</code> trap that overrides the default behavior of setting a value. The <code>set</code> trap receives four arguments:</p>
<ol>
<li><code>trapTarget</code> - the object that will receive the property (the proxy&rsquo;s target)</li>
<li><code>key</code> - the property key (string or symbol) to write to</li>
<li><code>value</code> - the value being written to the property</li>
<li><code>receiver</code> - the object on which the operation took place (usually the proxy)</li>
</ol>
<p><code>Reflect.set()</code> is the <code>set</code> trap&rsquo;s corresponding reflection method, and it&rsquo;s the default behavior for this operation. The <code>Reflect.set()</code> method accepts the same four arguments as the <code>set</code> proxy trap, making the method easy to use inside of the trap. The trap should return <code>true</code> if the property was set or <code>false</code> if not. (The <code>Reflect.set()</code> method returns the correct value based on whether the operation succeeded.)</p>
<p>To validate the values of properties, you&rsquo;d use the <code>set</code> trap and inspect the <code>value</code> that is passed in. Here&rsquo;s an example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;target&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">set</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ignore existing properties so as not to affect them
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">trapTarget</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nb">isNaN</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">&#34;Property must be a number.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// add the property
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// adding a new property
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">proxy</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">count</span><span class="p">);</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">count</span><span class="p">);</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// you can assign to name because it exists on target already
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;proxy&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;proxy&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;proxy&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// throws an error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">proxy</span><span class="p">.</span><span class="nx">anotherName</span> <span class="o">=</span> <span class="s2">&#34;proxy&#34;</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p>This code defines a proxy trap that validates the value of any new property added to <code>target</code>. When <code>proxy.count = 1</code> is executed, the <code>set</code> trap is called. The <code>trapTarget</code> value is equal to <code>target</code>, <code>key</code> is <code>&quot;count&quot;</code>, <code>value</code> is <code>1</code>, and <code>receiver</code> (not used in this example) is <code>proxy</code>. There is no existing property named <code>count</code> in <code>target</code>, so the proxy validates <code>value</code> by passing it to <code>isNaN()</code>. If the result is <code>NaN</code>, then the property value is not numeric and an error is thrown. Since this code sets <code>count</code> to <code>1</code>, the proxy calls <code>Reflect.set()</code> with the same four arguments that were passed to the trap to add the new property.</p>
<p>When <code>proxy.name</code> is assigned a string, the operation completes successfully. Since <code>target</code> already has a <code>name</code> property, that property is omitted from the validation check by calling the <code>trapTarget.hasOwnProperty()</code> method. This ensures that previously-existing non-numeric property values are still supported.</p>
<p>When <code>proxy.anotherName</code> is assigned a string, however, an error is thrown. The <code>anotherName</code> property doesn&rsquo;t exist on the target, so its value needs to be validated. During validation, the error is thrown because <code>&quot;proxy&quot;</code> isn&rsquo;t a numeric value.</p>
<p>Where the <code>set</code> proxy trap lets you intercept when properties are being written to, the <code>get</code> proxy trap lets you intercept when properties are being read.</p>
<h2 id="object-shape-validation-using-the-get-trap">Object Shape Validation Using the <code>get</code> Trap<a href="#object-shape-validation-using-the-get-trap" class="anchor" aria-hidden="true">#</a> </h2>
<p>One of the interesting, and sometimes confusing, aspects of JavaScript is that reading nonexistent properties doesn&rsquo;t throw an error. Instead, the value <code>undefined</code> is used for the property value, as in this example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// undefined
</span></span></span></code></pre></div>
  </figure>
</div>
<p>In most other languages, attempting to read <code>target.name</code> throws an error because the property doesn&rsquo;t exist. But JavaScript just uses <code>undefined</code> for the value of the <code>target.name</code> property. If you&rsquo;ve ever worked on a large code base, you&rsquo;ve probably seen how this behavior can cause significant problems, especially when there&rsquo;s a typo in the property name. Proxies can help you save yourself from this problem by having object shape validation.</p>
<p>An <em>object shape</em> is the collection of properties and methods available on the object. JavaScript engines use object shapes to optimize code, often creating classes to represent the objects. If you can safely assume an object will always have the same properties and methods it began with (a behavior you can enforce with the <code>Object.preventExtensions()</code> method, the <code>Object.seal()</code> method, or the <code>Object.freeze()</code> method), then throwing an error on attempts to access nonexistent properties can be helpful. Proxies make object shape validation easy.</p>
<p>Since property validation only has to happen when a property is read, you&rsquo;d use the <code>get</code> trap. The <code>get</code> trap is called when a property is read, even if that property doesn&rsquo;t exist on the object, and it takes three arguments:</p>
<ol>
<li><code>trapTarget</code> - the object from which the property is read (the proxy&rsquo;s target)</li>
<li><code>key</code> - the property key (a string or symbol) to read</li>
<li><code>receiver</code> - the object on which the operation took place (usually the proxy)</li>
</ol>
<p>These arguments mirror the <code>set</code> trap&rsquo;s arguments, with one noticeable difference. There&rsquo;s no <code>value</code> argument here because <code>get</code> traps don&rsquo;t write values. The <code>Reflect.get()</code> method accepts the same three arguments as the <code>get</code> trap and returns the property&rsquo;s default value.</p>
<p>You can use the <code>get</code> trap and <code>Reflect.get()</code> to throw an error when a property doesn&rsquo;t exist on the target, as follows:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">get</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">key</span> <span class="k">in</span> <span class="nx">receiver</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">&#34;Property &#34;</span> <span class="o">+</span> <span class="nx">key</span> <span class="o">+</span> <span class="s2">&#34; doesn&#39;t exist.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// adding a property still works
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;proxy&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;proxy&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// nonexistent properties throw an error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">nme</span><span class="p">);</span> <span class="c1">// throws error
</span></span></span></code></pre></div>
  </figure>
</div>
<p>In this example, the <code>get</code> trap intercepts property read operations. The <code>in</code> operator is used to determine if the property already exists on the <code>receiver</code>. The <code>receiver</code> is used with <code>in</code> instead of <code>trapTarget</code> in case <code>receiver</code> is a proxy with a <code>has</code> trap, a type I&rsquo;ll cover in the next section. Using <code>trapTarget</code> in this case would sidestep the <code>has</code> trap and potentially give you the wrong result. An error is thrown if the property doesn&rsquo;t exist, and otherwise, the default behavior is used.</p>
<p>This code allows new properties like <code>proxy.name</code> to be added, written to, and read from with no problems. The last line contains a typo: <code>proxy.nme</code> should probably be <code>proxy.name</code> instead. This throws an error because <code>nme</code> doesn&rsquo;t exist as a property.</p>
<h2 id="hiding-property-existence-using-the-has-trap">Hiding Property Existence Using the <code>has</code> Trap<a href="#hiding-property-existence-using-the-has-trap" class="anchor" aria-hidden="true">#</a> </h2>
<p>The <code>in</code> operator determines whether a property exists on a given object and returns <code>true</code> if there is either an own property or a prototype property matching the name or symbol. For example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">value</span><span class="o">:</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;value&#34;</span> <span class="k">in</span> <span class="nx">target</span><span class="p">);</span>     <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;toString&#34;</span> <span class="k">in</span> <span class="nx">target</span><span class="p">);</span>  <span class="c1">// true
</span></span></span></code></pre></div>
  </figure>
</div>
<p>Both <code>value</code> and <code>toString</code> exist on <code>object</code>, so in both cases the <code>in</code> operator returns <code>true</code>. The <code>value</code> property is an own property while <code>toString</code> is a prototype property (inherited from <code>Object</code>). Proxies allow you to intercept this operation and return a different value for <code>in</code> with the <code>has</code> trap.</p>
<p>The <code>has</code> trap is called whenever the <code>in</code> operator is used. When called, two arguments are passed to the <code>has</code> trap:</p>
<ol>
<li><code>trapTarget</code> - the object the property is read from (the proxy&rsquo;s target)</li>
<li><code>key</code> - the property key (string or symbol) to check</li>
</ol>
<p>The <code>Reflect.has()</code> method accepts these same arguments and returns the default response for the <code>in</code> operator. Using the <code>has</code> trap and <code>Reflect.has()</code> allows you to alter the behavior of <code>in</code> for some properties while falling back to default behavior for others. For instance, suppose you just want to hide the <code>value</code> property. You can do so like this:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;target&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">has</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">===</span> <span class="s2">&#34;value&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;value&#34;</span> <span class="k">in</span> <span class="nx">proxy</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;name&#34;</span> <span class="k">in</span> <span class="nx">proxy</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;toString&#34;</span> <span class="k">in</span> <span class="nx">proxy</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
  </figure>
</div>
<p>The <code>has</code> trap for <code>proxy</code> checks to see if <code>key</code> is <code>&quot;value&quot;</code> returns <code>false</code> if so. Otherwise, the default behavior is used via a call to the <code>Reflect.has()</code> method. As a result, the <code>in</code> operator returns <code>false</code> for the <code>value</code> property even though <code>value</code> actually exists on the target. The other properties, <code>name</code> and <code>toString</code>, correctly return <code>true</code> when used with the <code>in</code> operator.</p>
<h2 id="preventing-property-deletion-with-the-deleteproperty-trap">Preventing Property Deletion with the <code>deleteProperty</code> Trap<a href="#preventing-property-deletion-with-the-deleteproperty-trap" class="anchor" aria-hidden="true">#</a> </h2>
<p>The <code>delete</code> operator removes a property from an object and returns <code>true</code> when successful and <code>false</code> when unsuccessful. In strict mode, <code>delete</code> throws an error when you attempt to delete a nonconfigurable property; in nonstrict mode, <code>delete</code> simply returns <code>false</code>. Here&rsquo;s an example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;target&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="s2">&#34;name&#34;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">configurable</span><span class="o">:</span> <span class="kc">false</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;value&#34;</span> <span class="k">in</span> <span class="nx">target</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result1</span> <span class="o">=</span> <span class="k">delete</span> <span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result1</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;value&#34;</span> <span class="k">in</span> <span class="nx">target</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Note: The following line throws an error in strict mode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">result2</span> <span class="o">=</span> <span class="k">delete</span> <span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result2</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;name&#34;</span> <span class="k">in</span> <span class="nx">target</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
  </figure>
</div>
<p>The <code>value</code> property is deleted using the <code>delete</code> operator and, as a result, the <code>in</code> operator returns <code>false</code> in the third <code>console.log()</code> call. The nonconfigurable <code>name</code> property can&rsquo;t be deleted so the <code>delete</code> operator simply returns <code>false</code> (if this code is run in strict mode, an error is thrown instead). You can alter this behavior by using the <code>deleteProperty</code> trap in a proxy.</p>
<p>The <code>deleteProperty</code> trap is called whenever the <code>delete</code> operator is used on an object property. The trap is passed two arguments:</p>
<ol>
<li><code>trapTarget</code> - the object from which the property should be deleted (the proxy&rsquo;s target)</li>
<li><code>key</code> - the property key (string or symbol) to delete</li>
</ol>
<p>The <code>Reflect.deleteProperty()</code> method provides the default implementation of the <code>deleteProperty</code> trap and accepts the same two arguments. You can combine <code>Reflect.deleteProperty()</code> and the <code>deleteProperty</code> trap to change how the <code>delete</code> operator behaves. For instance, you could ensure that the <code>value</code> property can&rsquo;t be deleted:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;target&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="mi">42</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">===</span> <span class="s2">&#34;value&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Attempt to delete proxy.value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;value&#34;</span> <span class="k">in</span> <span class="nx">proxy</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result1</span> <span class="o">=</span> <span class="k">delete</span> <span class="nx">proxy</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result1</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;value&#34;</span> <span class="k">in</span> <span class="nx">proxy</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Attempt to delete proxy.name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;name&#34;</span> <span class="k">in</span> <span class="nx">proxy</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result2</span> <span class="o">=</span> <span class="k">delete</span> <span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result2</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;name&#34;</span> <span class="k">in</span> <span class="nx">proxy</span><span class="p">);</span> <span class="c1">// false
</span></span></span></code></pre></div>
  </figure>
</div>
<p>This code is very similar to the <code>has</code> trap example in that the <code>deleteProperty</code> trap checks to see if the <code>key</code> is <code>&quot;value&quot;</code> and returns <code>false</code> if so. Otherwise, the default behavior is used by calling the <code>Reflect.deleteProperty()</code> method. The <code>value</code> property can&rsquo;t be deleted through <code>proxy</code> because the operation is trapped, but the <code>name</code> property is deleted as expected. This approach is especially useful when you want to protect properties from deletion without throwing an error in strict mode.</p>
<h2 id="prototype-proxy-traps">Prototype Proxy Traps<a href="#prototype-proxy-traps" class="anchor" aria-hidden="true">#</a> </h2>
<p>Chapter 4 introduced the <code>Object.setPrototypeOf()</code> method that ECMAScript 6 added to complement the ECMAScript 5 <code>Object.getPrototypeOf()</code> method. Proxies allow you to intercept execution of both methods through the <code>setPrototypeOf</code> and <code>getPrototypeOf</code> traps. In both cases, the method on <code>Object</code> calls the trap of the corresponding name on the proxy, allowing you to alter the methods&rsquo; behavior.</p>
<p>Since there are two traps associated with prototype proxies, there&rsquo;s a set of methods associated with each type of trap. The <code>setPrototypeOf</code> trap receives these arguments:</p>
<ol>
<li><code>trapTarget</code> - the object for which the prototype should be set (the proxy&rsquo;s target)</li>
<li><code>proto</code> - the object to use for as the prototype</li>
</ol>
<p>These are the same arguments passed to the <code>Object.setPrototypeOf()</code> and <code>Reflect.setPrototypeOf()</code> methods. The <code>getPrototypeOf</code> trap, on the other hand, only receives the <code>trapTarget</code> argument, which is the argument passed to the <code>Object.getPrototypeOf()</code> and <code>Reflect.getPrototypeOf()</code> methods.</p>
<h3 id="how-prototype-proxy-traps-work">How Prototype Proxy Traps Work<a href="#how-prototype-proxy-traps-work" class="anchor" aria-hidden="true">#</a> </h3>
<p>There are some restrictions on these traps. First, the <code>getPrototypeOf</code> trap must return an object or <code>null</code>, and any other return value results in a runtime error. The return value check ensures that <code>Object.getPrototypeOf()</code> will always return an expected value. Similarly, the return value of the <code>setPrototypeOf</code> trap must be <code>false</code> if the operation doesn&rsquo;t succeed. When <code>setPrototypeOf</code> returns <code>false</code>, <code>Object.setPrototypeOf()</code> throws an error. If <code>setPrototypeOf</code> returns any value other than <code>false</code>, then <code>Object.setPrototypeOf()</code> assumes the operation succeeded.</p>
<p>The following example hides the prototype of the proxy by always returning <code>null</code> and also doesn&rsquo;t allow the prototype to be changed:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">proto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">targetProto</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxyProto</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">proxy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">targetProto</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxyProto</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxyProto</span><span class="p">);</span> <span class="c1">// null
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// succeeds
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// throws error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">proxy</span><span class="p">,</span> <span class="p">{});</span></span></span></code></pre></div>
  </figure>
</div>
<p>This code emphasizes the difference between the behavior of <code>target</code> and <code>proxy</code>. While <code>Object.getPrototypeOf()</code> returns a value for <code>target</code>, it returns <code>null</code> for <code>proxy</code> because the <code>getPrototypeOf</code> trap is called. Similarly, <code>Object.setPrototypeOf()</code> succeeds when used on <code>target</code> but throws an error when used on <code>proxy</code> due to the <code>setPrototypeOf</code> trap.</p>
<p>If you want to use the default behavior for these two traps, you can use the corresponding methods on <code>Reflect</code>. For instance, this code implements the default behavior for the <code>getPrototypeOf</code> and <code>setPrototypeOf</code> traps:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">proto</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">proto</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">targetProto</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxyProto</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">proxy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">targetProto</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxyProto</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// succeeds
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// also succeeds
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">proxy</span><span class="p">,</span> <span class="p">{});</span></span></span></code></pre></div>
  </figure>
</div>
<p>In this example, you can use <code>target</code> and <code>proxy</code> interchangeably and get the same results because the <code>getPrototypeOf</code> and <code>setPrototypeOf</code> traps are just passing through to use the default implementation. It&rsquo;s important that this example use the <code>Reflect.getPrototypeOf()</code> and <code>Reflect.setPrototypeOf()</code> methods rather than the methods of the same name on <code>Object</code> due to some important differences.</p>
<h3 id="why-two-sets-of-methods">Why Two Sets of Methods?<a href="#why-two-sets-of-methods" class="anchor" aria-hidden="true">#</a> </h3>
<p>The confusing aspect of <code>Reflect.getPrototypeOf()</code> and <code>Reflect.setPrototypeOf()</code> is that they look suspiciously similar to the <code>Object.getPrototypeOf()</code> and <code>Object.setPrototypeOf()</code> methods. While both sets of methods perform similar operations, there are some distinct differences between the two.</p>
<p>To begin, <code>Object.getPrototypeOf()</code> and <code>Object.setPrototypeOf()</code> are higher-level operations that were created for developer use from the start. The <code>Reflect.getPrototypeOf()</code> and <code>Reflect.setPrototypeOf()</code> methods are lower-level operations that give developers access to the previously internal-only <code>[[GetPrototypeOf]]</code> and <code>[[SetPrototypeOf]]</code> operations. The <code>Reflect.getPrototypeOf()</code> method is the wrapper for the internal <code>[[GetPrototypeOf]]</code> operation (with some input validation). The <code>Reflect.setPrototypeOf()</code> method and <code>[[SetPrototypeOf]]</code> have the same relationship. The corresponding methods on <code>Object</code> also call <code>[[GetPrototypeOf]]</code> and <code>[[SetPrototypeOf]]</code> but perform a few steps before the call and inspect the return value to determine how to behave.</p>
<p>The <code>Reflect.getPrototypeOf()</code> method throws an error if its argument is not an object, while <code>Object.getPrototypeOf()</code> first coerces the value into an object before performing the operation. If you were to pass a number into each method, you&rsquo;d get a different result:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result1</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result1</span> <span class="o">===</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// throws an error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Reflect</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<p>The <code>Object.getPrototypeOf()</code> method allows you to retrieve a prototype for the number <code>1</code> because it first coerces the value into a <code>Number</code> object and then returns <code>Number.prototype</code>. The <code>Reflect.getPrototypeOf()</code> method doesn&rsquo;t coerce the value, and since <code>1</code> isn&rsquo;t an object, it throws an error.</p>
<p>The <code>Reflect.setPrototypeOf()</code> method also has a few more differences from the <code>Object.setPrototypeOf()</code> method. First, <code>Reflect.setPrototypeOf()</code> returns a boolean value indicating whether the operation was successful. A <code>true</code> value is returned for success, and <code>false</code> is returned for failure. If <code>Object.setPrototypeOf()</code> fails, it throws an error.</p>
<p>As the first example under &ldquo;How Prototype Proxy Traps Work&rdquo; showed, when the <code>setPrototypeOf</code> proxy trap returns <code>false</code>, it causes <code>Object.setPrototypeOf()</code> to throw an error. The <code>Object.setPrototypeOf()</code> method returns the first argument as its value and therefore isn&rsquo;t suitable for implementing the default behavior of the <code>setPrototypeOf</code> proxy trap. The following code demonstrates these differences:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target1</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result1</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">target1</span><span class="p">,</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result1</span> <span class="o">===</span> <span class="nx">target1</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target2</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result2</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">target2</span><span class="p">,</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result2</span> <span class="o">===</span> <span class="nx">target2</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result2</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
  </figure>
</div>
<p>In this example, <code>Object.setPrototypeOf()</code> returns <code>target1</code> as its value, but <code>Reflect.setPrototypeOf()</code> returns <code>true</code>. This subtle difference is very important. You&rsquo;ll see more seemingly duplicate methods on <code>Object</code> and <code>Reflect</code>, but always be sure to use the method on <code>Reflect</code> inside any proxy traps.</p>
<p>I&gt; Both sets of methods will call the <code>getPrototypeOf</code> and <code>setPrototypeOf</code> proxy traps when used on a proxy.</p>
<h2 id="object-extensibility-traps">Object Extensibility Traps<a href="#object-extensibility-traps" class="anchor" aria-hidden="true">#</a> </h2>
<p>ECMAScript 5 added object extensibility modification through the <code>Object.preventExtensions()</code> and <code>Object.isExtensible()</code> methods, and ECMAScript 6 allows proxies to intercept those method calls to the underlying objects through the <code>preventExtensions</code> and <code>isExtensible</code> traps. Both traps receive a single argument called <code>trapTarget</code> that is the object on which the method was called. The <code>isExtensible</code> trap must return a boolean value indicating whether the object is extensible while the <code>preventExtensions</code> trap must return a boolean value indicating if the operation succeeded.</p>
<p>There are also <code>Reflect.preventExtensions()</code> and <code>Reflect.isExtensible()</code> methods to implement the default behavior. Both return boolean values, so they can be used directly in their corresponding traps.</p>
<h3 id="two-basic-examples">Two Basic Examples<a href="#two-basic-examples" class="anchor" aria-hidden="true">#</a> </h3>
<p>To see object extensibility traps in action, consider the following code, which implements the default behavior for the <code>isExtensible</code> and <code>preventExtensions</code> traps:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">isExtensible</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">target</span><span class="p">));</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">proxy</span><span class="p">));</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">proxy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">target</span><span class="p">));</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">proxy</span><span class="p">));</span> <span class="c1">// false
</span></span></span></code></pre></div>
  </figure>
</div>
<p>This example shows that both <code>Object.preventExtensions()</code> and <code>Object.isExtensible()</code> correctly pass through from <code>proxy</code> to <code>target</code>. You can, of course, also change the behavior. For example, if you don&rsquo;t want to allow <code>Object.preventExtensions()</code> to succeed on your proxy, you could return <code>false</code> from the <code>preventExtensions</code> trap:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">isExtensible</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">target</span><span class="p">));</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">proxy</span><span class="p">));</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">proxy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">target</span><span class="p">));</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="nx">proxy</span><span class="p">));</span> <span class="c1">// true
</span></span></span></code></pre></div>
  </figure>
</div>
<p>Here, the call to <code>Object.preventExtensions(proxy)</code> is effectively ignored because the <code>preventExtensions</code> trap returns <code>false</code>. The operation isn&rsquo;t forwarded to the underlying <code>target</code>, so <code>Object.isExtensible()</code> returns <code>true</code>.</p>
<h3 id="duplicate-extensibility-methods">Duplicate Extensibility Methods<a href="#duplicate-extensibility-methods" class="anchor" aria-hidden="true">#</a> </h3>
<p>You may have noticed that, once again, there are seemingly duplicate methods on <code>Object</code> and <code>Reflect</code>. In this case, they&rsquo;re more similar than not. The methods <code>Object.isExtensible()</code> and <code>Reflect.isExtensible()</code> are similar except when passed a non-object value. In that case, <code>Object.isExtensible()</code> always returns <code>false</code> while <code>Reflect.isExtensible()</code> throws an error. Here&rsquo;s an example of that behavior:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result1</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result1</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// throws error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">result2</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">isExtensible</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<p>This restriction is similar to the difference between the <code>Object.getPrototypeOf()</code> and <code>Reflect.getPrototypeOf()</code> methods, as the method with lower-level functionality has stricter error checks than its higher-level counterpart.</p>
<p>The <code>Object.preventExtensions()</code> and <code>Reflect.preventExtensions()</code> methods are also very similar. The <code>Object.preventExtensions()</code> method always returns the value that was passed to it as an argument even if the value isn&rsquo;t an object. The <code>Reflect.preventExtensions()</code> method, on the other hand, throws an error if the argument isn&rsquo;t an object; if the argument is an object, then <code>Reflect.preventExtensions()</code> returns <code>true</code> when the operation succeeds or <code>false</code> if not. For example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result1</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result1</span><span class="p">);</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result2</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="nx">target</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result2</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// throws error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">result3</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">preventExtensions</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<p>Here, <code>Object.preventExtensions()</code> passes through the value <code>2</code> as its return value even though <code>2</code> isn&rsquo;t an object. The <code>Reflect.preventExtensions()</code> method returns <code>true</code> when an object is passed to it and throws an error when <code>2</code> is passed to it.</p>
<h2 id="property-descriptor-traps">Property Descriptor Traps<a href="#property-descriptor-traps" class="anchor" aria-hidden="true">#</a> </h2>
<p>One of the most important features of ECMAScript 5 was the ability to define property attributes using the <code>Object.defineProperty()</code> method. In previous versions of JavaScript, there was no way to define an accessor property, make a property read-only, or make a property nonenumerable. All of these are possible with the <code>Object.defineProperty()</code> method, and you can retrieve those attributes with the <code>Object.getOwnPropertyDescriptor()</code> method.</p>
<p>Proxies let you intercept calls to <code>Object.defineProperty()</code> and <code>Object.getOwnPropertyDescriptor()</code> using the <code>defineProperty</code> and <code>getOwnPropertyDescriptor</code> traps, respectively. The <code>defineProperty</code> trap receives the following arguments:</p>
<ol>
<li><code>trapTarget</code> - the object on which the property should be defined (the proxy&rsquo;s target)</li>
<li><code>key</code> - the string or symbol for the property</li>
<li><code>descriptor</code> - the descriptor object for the property</li>
</ol>
<p>The <code>defineProperty</code> trap requires you to return <code>true</code> if the operation is successful and <code>false</code> if not. The <code>getOwnPropertyDescriptor</code> traps receives only <code>trapTarget</code> and <code>key</code>, and you are expected to return the descriptor. The corresponding <code>Reflect.defineProperty()</code> and <code>Reflect.getOwnPropertyDescriptor()</code> methods accept the same arguments as their proxy trap counterparts. Here&rsquo;s an example that just implements the default behavior for each trap:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">defineProperty</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">proxy</span><span class="p">,</span> <span class="s2">&#34;name&#34;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;proxy&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;proxy&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">proxy</span><span class="p">,</span> <span class="s2">&#34;name&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// &#34;proxy&#34;
</span></span></span></code></pre></div>
  </figure>
</div>
<p>This code defines a property called <code>&quot;name&quot;</code> on the proxy with the <code>Object.defineProperty()</code> method. The property descriptor for that property is then retrieved by the <code>Object.getOwnPropertyDescriptor()</code> method.</p>
<h3 id="blocking-objectdefineproperty">Blocking Object.defineProperty()<a href="#blocking-objectdefineproperty" class="anchor" aria-hidden="true">#</a> </h3>
<p>The <code>defineProperty</code> trap requires you to return a boolean value to indicate whether the operation was successful. When <code>true</code> is returned, <code>Object.defineProperty()</code> succeeds as usual; when <code>false</code> is returned, <code>Object.defineProperty()</code> throws an error. You can use this functionality to restrict the kinds of properties that the <code>Object.defineProperty()</code> method can define. For instance, if you want to prevent symbol properties from being defined, you could check that the key is a string and return <code>false</code> if not, like this:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">defineProperty</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">key</span> <span class="o">===</span> <span class="s2">&#34;symbol&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">proxy</span><span class="p">,</span> <span class="s2">&#34;name&#34;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;proxy&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;proxy&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">nameSymbol</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s2">&#34;name&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// throws error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">proxy</span><span class="p">,</span> <span class="nx">nameSymbol</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;proxy&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
  </figure>
</div>
<p>The <code>defineProperty</code> proxy trap returns <code>false</code> when <code>key</code> is a symbol and otherwise proceeds with the default behavior. When <code>Object.defineProperty()</code> is called with <code>&quot;name&quot;</code> as the key, the method succeeds because the key is a string. When <code>Object.defineProperty()</code> is called with <code>nameSymbol</code>, it throws an error because the <code>defineProperty</code> trap returns <code>false</code>.</p>
<p>I&gt; You can also have <code>Object.defineProperty()</code> silently fail by returning <code>true</code> and not calling the <code>Reflect.defineProperty()</code> method. That will suppress the error while not actually defining the property.</p>
<h3 id="descriptor-object-restrictions">Descriptor Object Restrictions<a href="#descriptor-object-restrictions" class="anchor" aria-hidden="true">#</a> </h3>
<p>To ensure consistent behavior when using the <code>Object.defineProperty()</code> and <code>Object.getOwnPropertyDescriptor()</code> methods, descriptor objects passed to the <code>defineProperty</code> trap are normalized. Objects returned from <code>getOwnPropertyDescriptor</code> trap are always validated for the same reason.</p>
<p>No matter what object is passed as the third argument to the <code>Object.defineProperty()</code> method, only the properties <code>enumerable</code>, <code>configurable</code>, <code>value</code>, <code>writable</code>, <code>get</code>, and <code>set</code> will be on the descriptor object passed to the <code>defineProperty</code> trap. For example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">defineProperty</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// &#34;proxy&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">descriptor</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">proxy</span><span class="p">,</span> <span class="s2">&#34;name&#34;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;proxy&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;custom&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span></span></span></code></pre></div>
  </figure>
</div>
<p>Here, <code>Object.defineProperty()</code> is called with a nonstandard <code>name</code> property on the third argument. When the <code>defineProperty</code> trap is called, the <code>descriptor</code> object doesn&rsquo;t have a <code>name</code> property but does have a <code>value</code> property. That&rsquo;s because <code>descriptor</code> isn&rsquo;t a reference to the actual third argument passed to the <code>Object.defineProperty()</code> method, but rather a new object that contains only the allowable properties. The <code>Reflect.defineProperty()</code> method also ignores any nonstandard properties on the descriptor.</p>
<p>The <code>getOwnPropertyDescriptor</code> trap has a slightly different restriction that requires the return value to be <code>null</code>, <code>undefined</code>, or an object. If an object is returned, only <code>enumerable</code>, <code>configurable</code>, <code>value</code>, <code>writable</code>, <code>get</code>, and <code>set</code> are allowed as own properties of the object. An error is thrown if you return an object with an own property that isn&rsquo;t allowed, as this code shows:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;proxy&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// throws error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">descriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">proxy</span><span class="p">,</span> <span class="s2">&#34;name&#34;</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<p>The property <code>name</code> isn&rsquo;t allowable on property descriptors, so when <code>Object.getOwnPropertyDescriptor()</code> is called, the <code>getOwnPropertyDescriptor</code> return value triggers an error. This restriction ensures that the value returned by <code>Object.getOwnPropertyDescriptor()</code> always has a reliable structure regardless of use on proxies.</p>
<h3 id="duplicate-descriptor-methods">Duplicate Descriptor Methods<a href="#duplicate-descriptor-methods" class="anchor" aria-hidden="true">#</a> </h3>
<p>Once again, ECMAScript 6 has some confusingly similar methods, as the <code>Object.defineProperty()</code> and <code>Object.getOwnPropertyDescriptor()</code> methods appear to do the same thing as the <code>Reflect.defineProperty()</code> and <code>Reflect.getOwnPropertyDescriptor()</code> methods, respectively. Like other method pairs discussed earlier in this chapter, these have some subtle but important differences.</p>
<h4 id="defineproperty-methods">defineProperty() Methods<a href="#defineproperty-methods" class="anchor" aria-hidden="true">#</a> </h4>
<p>The <code>Object.defineProperty()</code> and <code>Reflect.defineProperty()</code> methods are exactly the same except for their return values. The <code>Object.defineProperty()</code> method returns the first argument, while <code>Reflect.defineProperty()</code> returns <code>true</code> if the operation succeeded and <code>false</code> if not. For example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result1</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="s2">&#34;name&#34;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;target &#34;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">result1</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">result2</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="s2">&#34;name&#34;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;reflect&#34;</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result2</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
  </figure>
</div>
<p>When <code>Object.defineProperty()</code> is called on <code>target</code>, the return value is <code>target</code>. When <code>Reflect.defineProperty()</code> is called on <code>target</code>, the return value is <code>true</code>, indicating that the operation succeeded. Since the <code>defineProperty</code> proxy trap requires a boolean value to be returned, it&rsquo;s better to use <code>Reflect.defineProperty()</code> to implement the default behavior when necessary.</p>
<h4 id="getownpropertydescriptor-methods">getOwnPropertyDescriptor() Methods<a href="#getownpropertydescriptor-methods" class="anchor" aria-hidden="true">#</a> </h4>
<p>The <code>Object.getOwnPropertyDescriptor()</code> method coerces its first argument into an object when a primitive value is passed and then continues the operation. On the other hand, the <code>Reflect.getOwnPropertyDescriptor()</code> method throws an error if the first argument is a primitive value. Here&rsquo;s an example showing both:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">descriptor1</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&#34;name&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">descriptor1</span><span class="p">);</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// throws an error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">descriptor2</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&#34;name&#34;</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<p>The <code>Object.getOwnPropertyDescriptor()</code> method returns <code>undefined</code> because it coerces <code>2</code> into an object, and that object has no <code>name</code> property. This is the standard behavior of the method when a property with the given name isn&rsquo;t found on an object. When <code>Reflect.getOwnPropertyDescriptor()</code> is called, however, an error is thrown immediately because that method doesn&rsquo;t accept primitive values for the first argument.</p>
<h2 id="the-ownkeys-trap">The <code>ownKeys</code> Trap<a href="#the-ownkeys-trap" class="anchor" aria-hidden="true">#</a> </h2>
<p>The <code>ownKeys</code> proxy trap intercepts the internal method <code>[[OwnPropertyKeys]]</code> and allows you to override that behavior by returning an array of values. This array is used in four methods: the <code>Object.keys()</code> method, the <code>Object.getOwnPropertyNames()</code> method, the <code>Object.getOwnPropertySymbols()</code> method, and the <code>Object.assign()</code> method. (The <code>Object.assign()</code> method uses the array to determine which properties to copy.)</p>
<p>The default behavior for the <code>ownKeys</code> trap is implemented by the <code>Reflect.ownKeys()</code> method and returns an array of all own property keys, including both strings and symbols. The <code>Object.getOwnProperyNames()</code> method and the <code>Object.keys()</code> method filter symbols out of the array and returns the result while <code>Object.getOwnPropertySymbols()</code> filters the strings out of the array and returns the result. The <code>Object.assign()</code> method uses the array with both strings and symbols.</p>
<p>The <code>ownKeys</code> trap receives a single argument, the target, and must always return an array or array-like object; otherwise, an error is thrown. You can use the <code>ownKeys</code> trap to, for example, filter out certain property keys that you don&rsquo;t want used when the <code>Object.keys()</code>, the <code>Object.getOwnPropertyNames()</code> method, the <code>Object.getOwnPropertySymbols()</code> method, or the <code>Object.assign()</code> method is used. Suppose you don&rsquo;t want to include any property names that begin with an underscore character, a common notation in JavaScript indicating that a field is private. You can use the <code>ownKeys</code> trap to filter out those keys as follows:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ownKeys</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">).</span><span class="nx">filter</span><span class="p">((</span><span class="nx">key</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">typeof</span> <span class="nx">key</span> <span class="o">!==</span> <span class="s2">&#34;string&#34;</span> <span class="o">||</span> <span class="nx">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!==</span> <span class="s2">&#34;_&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">nameSymbol</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s2">&#34;name&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;proxy&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">.</span><span class="nx">_name</span> <span class="o">=</span> <span class="s2">&#34;private&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">proxy</span><span class="p">[</span><span class="nx">nameSymbol</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;symbol&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">names</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">proxy</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="nx">keys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">proxy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">symbols</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertySymbols</span><span class="p">(</span><span class="nx">proxy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">names</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// &#34;name&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">keys</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// &#34;name&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">symbols</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// &#34;Symbol(name)&#34;
</span></span></span></code></pre></div>
  </figure>
</div>
<p>This example uses an <code>ownKeys</code> trap that first calls <code>Reflect.ownKeys()</code> to get the default list of keys for the target. Then, the <code>filter()</code> method is used to filter out keys that are strings and begin with an underscore character. Then, three properties are added to the <code>proxy</code> object: <code>name</code>, <code>_name</code>, and <code>nameSymbol</code>. When <code>Object.getOwnPropertyNames()</code> and <code>Object.keys()</code> is called on <code>proxy</code>, only the <code>name</code> property is returned. Similarly, only <code>nameSymbol</code> is returned when <code>Object.getOwnPropertySymbols()</code> is called on <code>proxy</code>. The <code>_name</code> property doesn&rsquo;t appear in either result because it is filtered out.</p>
<p>I&gt; The <code>ownKeys</code> trap also affects the <code>for-in</code> loop, which calls the trap to determine which keys to use inside of the loop.</p>
<h2 id="function-proxies-with-the-apply-and-construct-traps">Function Proxies with the <code>apply</code> and <code>construct</code> Traps<a href="#function-proxies-with-the-apply-and-construct-traps" class="anchor" aria-hidden="true">#</a> </h2>
<p>Of all the proxy traps, only <code>apply</code> and <code>construct</code> require the proxy target to be a function. Recall from Chapter 3 that functions have two internal methods called <code>[[Call]]</code> and <code>[[Construct]]</code> that are executed when a function is called without and with the <code>new</code> operator, respectively. The <code>apply</code> and <code>construct</code> traps correspond to and let you override those internal methods. When a function is called without <code>new</code>, the <code>apply</code> trap receives, and <code>Reflect.apply()</code> expects, the following arguments:</p>
<ol>
<li><code>trapTarget</code> - the function being executed (the proxy&rsquo;s target)</li>
<li><code>thisArg</code> - the value of <code>this</code> inside of the function during the call</li>
<li><code>argumentsList</code> - an array of arguments passed to the function</li>
</ol>
<p>The <code>construct</code> trap, which is called when the function is executed using <code>new</code>, receives the following arguments:</p>
<ol>
<li><code>trapTarget</code> - the function being executed (the proxy&rsquo;s target)</li>
<li><code>argumentsList</code> - an array of arguments passed to the function</li>
</ol>
<p>The <code>Reflect.construct()</code> method also accepts these two arguments and has an optional third argument called <code>newTarget</code>. When given, the <code>newTarget</code> argument specifies the value of <code>new.target</code> inside of the function.</p>
<p>Together, the <code>apply</code> and <code>construct</code> traps completely control the behavior of any proxy target function. To mimic the default behavior of a function, you can do this:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">apply</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">thisArg</span><span class="p">,</span> <span class="nx">argumentList</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">thisArg</span><span class="p">,</span> <span class="nx">argumentList</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">construct</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">argumentList</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">construct</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">argumentList</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// a proxy with a function as its target looks like a function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">proxy</span><span class="p">);</span> <span class="c1">// &#34;function&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxy</span><span class="p">());</span> <span class="c1">// 42
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">proxy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span> <span class="k">instanceof</span> <span class="nx">proxy</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span> <span class="k">instanceof</span> <span class="nx">target</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
  </figure>
</div>
<p>This example has a function that returns the number 42. The proxy for that function uses the <code>apply</code> and <code>construct</code> traps to delegate those behaviors to the <code>Reflect.apply()</code> and <code>Reflect.construct()</code> methods, respectively. The end result is that the proxy function works exactly like the target function, including identifying itself as a function when <code>typeof</code> is used. The proxy is called without <code>new</code> to return 42 and then is called with <code>new</code> to create an object called <code>instance</code>. The <code>instance</code> object is considered an instance of both <code>proxy</code> and <code>target</code> because <code>instanceof</code> uses the prototype chain to determine this information. Prototype chain lookup is not affected by this proxy, which is why <code>proxy</code> and <code>target</code> appear to have the same prototype to the JavaScript engine.</p>
<h3 id="validating-function-parameters">Validating Function Parameters<a href="#validating-function-parameters" class="anchor" aria-hidden="true">#</a> </h3>
<p>The <code>apply</code> and <code>construct</code> traps open up a lot of possibilities for altering the way a function is executed. For instance, suppose you want to validate that all arguments are of a specific type. You can check the arguments in the <code>apply</code> trap:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="c1">// adds together all arguments
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">sum</span><span class="p">(...</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">values</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">previous</span><span class="p">,</span> <span class="nx">current</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">previous</span> <span class="o">+</span> <span class="nx">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">sumProxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">sum</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">apply</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">thisArg</span><span class="p">,</span> <span class="nx">argumentList</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">argumentList</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">arg</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">arg</span> <span class="o">!==</span> <span class="s2">&#34;number&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">&#34;All arguments must be numbers.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">thisArg</span><span class="p">,</span> <span class="nx">argumentList</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="nx">construct</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">argumentList</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">&#34;This function can&#39;t be called with new.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sumProxy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">));</span> <span class="c1">// 10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// throws error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sumProxy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;2&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// also throws error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">sumProxy</span><span class="p">();</span></span></span></code></pre></div>
  </figure>
</div>
<p>This example uses the <code>apply</code> trap to ensure that all arguments are numbers. The <code>sum()</code> function adds up all of the arguments that are passed. If a non-number value is passed, the function will still attempt the operation, which can cause unexpected results. By wrapping <code>sum()</code> inside the <code>sumProxy()</code> proxy, this code intercepts function calls and ensures that each argument is a number before allowing the call to proceed. To be safe, the code also uses the <code>construct</code> trap to ensure that the function can&rsquo;t be called with <code>new</code>.</p>
<p>You can also do the opposite, ensuring that a function must be called with <code>new</code> and validating its arguments to be numbers:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Numbers</span><span class="p">(...</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">values</span> <span class="o">=</span> <span class="nx">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">NumbersProxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">Numbers</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">apply</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">thisArg</span><span class="p">,</span> <span class="nx">argumentList</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">&#34;This function must be called with new.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">},</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">construct</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">argumentList</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">argumentList</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">arg</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">arg</span> <span class="o">!==</span> <span class="s2">&#34;number&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">&#34;All arguments must be numbers.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">construct</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">argumentList</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">NumbersProxy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">values</span><span class="p">);</span> <span class="c1">// [1,2,3,4]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// throws error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">NumbersProxy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<p>Here, the <code>apply</code> trap throws an error while the <code>construct</code> trap uses the <code>Reflect.construct()</code> method to validate input and return a new instance. Of course, you can accomplish the same thing without proxies using <code>new.target</code> instead.</p>
<h3 id="calling-constructors-without-new">Calling Constructors Without new<a href="#calling-constructors-without-new" class="anchor" aria-hidden="true">#</a> </h3>
<p>Chapter 3 introduced the <code>new.target</code> metaproperty. To review, <code>new.target</code> is a reference to the function on which <code>new</code> is called, meaning that you can tell if a function was called using <code>new</code> or not by checking the value of <code>new.target</code> like this:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Numbers</span><span class="p">(...</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="s2">&#34;undefined&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">&#34;This function must be called with new.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">values</span> <span class="o">=</span> <span class="nx">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Numbers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">values</span><span class="p">);</span> <span class="c1">// [1,2,3,4]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// throws error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Numbers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<p>This example throws an error when <code>Numbers</code> is called without using <code>new</code>, which is similar to the example in the &ldquo;Validating Function Parameters&rdquo; section but doesn&rsquo;t use a proxy. Writing code like this is much simpler than using a proxy and is preferable if your only goal is to prevent calling the function without <code>new</code>. But sometimes you aren&rsquo;t in control of the function whose behavior needs to be modified. In that case, using a proxy makes sense.</p>
<p>Suppose the <code>Numbers</code> function is defined in code you can&rsquo;t modify. You know that the code relies on <code>new.target</code> and want to avoid that check while still calling the function. The behavior when using <code>new</code> is already set, so you can just use the <code>apply</code> trap:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">Numbers</span><span class="p">(...</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="s2">&#34;undefined&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">&#34;This function must be called with new.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">this</span><span class="p">.</span><span class="nx">values</span> <span class="o">=</span> <span class="nx">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">NumbersProxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">Numbers</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">apply</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">thisArg</span><span class="p">,</span> <span class="nx">argumentsList</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">construct</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">argumentsList</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">instance</span> <span class="o">=</span> <span class="nx">NumbersProxy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">values</span><span class="p">);</span> <span class="c1">// [1,2,3,4]
</span></span></span></code></pre></div>
  </figure>
</div>
<p>The <code>NumbersProxy</code> function allows you to call <code>Numbers</code> without using <code>new</code> and have it behave as if <code>new</code> were used. To do so, the <code>apply</code> trap calls <code>Reflect.construct()</code> with the arguments passed into <code>apply</code>. The <code>new.target</code> inside of <code>Numbers</code> is equal to <code>Numbers</code> itself, and no error is thrown. While this is a simple example of modifying <code>new.target</code>, you can also do so more directly.</p>
<h3 id="overriding-abstract-base-class-constructors">Overriding Abstract Base Class Constructors<a href="#overriding-abstract-base-class-constructors" class="anchor" aria-hidden="true">#</a> </h3>
<p>You can go one step further and specify the third argument to <code>Reflect.construct()</code> as the specific value to assign to <code>new.target</code>. This is useful when a function is checking <code>new.target</code> against a known value, such as when creating an abstract base class constructor (discussed in Chapter 9). In an abstract base class constructor, <code>new.target</code> is expected to be something other than the class constructor itself, as in this example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">AbstractNumbers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(...</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">AbstractNumbers</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">&#34;This function must be inherited from.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">values</span> <span class="o">=</span> <span class="nx">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Numbers</span> <span class="kr">extends</span> <span class="nx">AbstractNumbers</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Numbers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">values</span><span class="p">);</span> <span class="c1">// [1,2,3,4]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// throws error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">new</span> <span class="nx">AbstractNumbers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<p>When <code>new AbstractNumbers()</code> is called, <code>new.target</code> is equal to <code>AbstractNumbers</code> and an error is thrown. Calling <code>new Numbers()</code> still works because <code>new.target</code> is equal to <code>Numbers</code>. You can bypass this restriction by manually assigning <code>new.target</code> with a proxy:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">AbstractNumbers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(...</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">AbstractNumbers</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s2">&#34;This function must be inherited from.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">values</span> <span class="o">=</span> <span class="nx">values</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">AbstractNumbersProxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">AbstractNumbers</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">construct</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">argumentList</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">construct</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">argumentList</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AbstractNumbersProxy</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">values</span><span class="p">);</span> <span class="c1">// [1,2,3,4]
</span></span></span></code></pre></div>
  </figure>
</div>
<p>The <code>AbstractNumbersProxy</code> uses the <code>construct</code> trap to intercept the call to the <code>new AbstractNumbersProxy()</code> method. Then, the <code>Reflect.construct()</code> method is called with arguments from the trap and adds an empty function as the third argument. That empty function is used as the value of <code>new.target</code> inside of the constructor. Because <code>new.target</code> is not equal to <code>AbstractNumbers</code>, no error is thrown and the constructor executes completely.</p>
<h3 id="callable-class-constructors">Callable Class Constructors<a href="#callable-class-constructors" class="anchor" aria-hidden="true">#</a> </h3>
<p>Chapter 9 explained that class constructors must always be called with <code>new</code>. That happens because the internal <code>[[Call]]</code> method for class constructors is specified to throw an error. But proxies can intercept calls to the <code>[[Call]]</code> method, meaning you can effectively create callable class constructors by using a proxy. For instance, if you want a class constructor to work without using <code>new</code>, you can use the <code>apply</code> trap to create a new instance. Here&rsquo;s some sample code:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">PersonProxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">Person</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">apply</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">thisArg</span><span class="p">,</span> <span class="nx">argumentList</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nx">trapTarget</span><span class="p">(...</span><span class="nx">argumentList</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">me</span> <span class="o">=</span> <span class="nx">PersonProxy</span><span class="p">(</span><span class="s2">&#34;Nicholas&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;Nicholas&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span> <span class="k">instanceof</span> <span class="nx">Person</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">me</span> <span class="k">instanceof</span> <span class="nx">PersonProxy</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
  </figure>
</div>
<p>The <code>PersonProxy</code> object is a proxy of the <code>Person</code> class constructor. Class constructors are just functions, so they behave like functions when used in proxies. The <code>apply</code> trap overrides the default behavior and instead returns a new instance of <code>trapTarget</code> that&rsquo;s equal to <code>Person</code>. (I used <code>trapTarget</code> in this example to show that you don&rsquo;t need to manually specify the class.) The <code>argumentList</code> is passed to <code>trapTarget</code> using the spread operator to pass each argument separately. Calling <code>PersonProxy()</code> without using <code>new</code> returns an instance of <code>Person</code>; if you attempt to call <code>Person()</code> without <code>new</code>, the constructor will still throw an error. Creating callable class constructors is something that is only possible using proxies.</p>
<h2 id="revocable-proxies">Revocable Proxies<a href="#revocable-proxies" class="anchor" aria-hidden="true">#</a> </h2>
<p>Normally, a proxy can&rsquo;t be unbound from its target once the proxy has been created. All of the examples to this point in this chapter have used nonrevocable proxies. But there may be situations when you want to revoke a proxy so that it can no longer be used. You&rsquo;ll find it most helpful to revoke proxies when you want to provide an object through an API for security purposes and maintain the ability to cut off access to some functionality at any point in time.</p>
<p>You can create revocable proxies with the <code>Proxy.revocable()</code> method, which takes the same arguments as the <code>Proxy</code> constructor&ndash;a target object and the proxy handler. The return value is an object with the following properties:</p>
<ol>
<li><code>proxy</code> - the proxy object that can be revoked</li>
<li><code>revoke</code> - the function to call to revoke the proxy</li>
</ol>
<p>When the <code>revoke()</code> function is called, no further operations can be performed through the <code>proxy</code>. Any attempt to interact with the proxy object in a way that would trigger a proxy trap throws an error. For example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;target&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="p">{</span> <span class="nx">proxy</span><span class="p">,</span> <span class="nx">revoke</span> <span class="p">}</span> <span class="o">=</span> <span class="nb">Proxy</span><span class="p">.</span><span class="nx">revocable</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;target&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">revoke</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// throws error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">proxy</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span></span></span></code></pre></div>
  </figure>
</div>
<p>This example creates a revocable proxy. It uses destructuring to assign the <code>proxy</code> and <code>revoke</code> variables to the properties of the same name on the object returned by the <code>Proxy.revocable()</code> method. After that, the <code>proxy</code> object can be used just like a nonrevocable proxy object, so <code>proxy.name</code> returns <code>&quot;target&quot;</code> because it passes through to <code>target.name</code>. Once the <code>revoke()</code> function is called, however, <code>proxy</code> no longer functions. Attempting to access <code>proxy.name</code> throws an error, as will any other operation that would trigger a trap on <code>proxy</code>.</p>
<h2 id="solving-the-array-problem">Solving the Array Problem<a href="#solving-the-array-problem" class="anchor" aria-hidden="true">#</a> </h2>
<p>At the beginning of this chapter, I explained how developers couldn&rsquo;t mimic the behavior of an array accurately in JavaScript prior to ECMAScript 6. Proxies and the reflection API allow you to create an object that behaves in the same manner as the built-in <code>Array</code> type when properties are added and removed. To refresh your memory, here&rsquo;s an example showing the behavior that proxies help to mimick:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;red&#34;</span><span class="p">,</span> <span class="s2">&#34;green&#34;</span><span class="p">,</span> <span class="s2">&#34;blue&#34;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;black&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span> <span class="c1">// &#34;black&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// &#34;green&#34;
</span></span></span></code></pre></div>
  </figure>
</div>
<p>There are two particularly important behaviors to notice in this example:</p>
<ol>
<li>The <code>length</code> property is increased to 4 when <code>colors[3]</code> is assigned a value.</li>
<li>The last two items in the array are deleted when the <code>length</code> property is set to 2.</li>
</ol>
<p>These two behaviors are the only ones that need to be mimicked to accurately recreate how built-in arrays work. The next few sections describe how to make an object that correctly mimics them.</p>
<h3 id="detecting-array-indices">Detecting Array Indices<a href="#detecting-array-indices" class="anchor" aria-hidden="true">#</a> </h3>
<p>Keep in mind that assigning to an integer property key is a special case for arrays, as those are treated differently from non-integer keys. The ECMAScript 6 specification gives these instructions on how to determine if a property key is an array index:</p>
<blockquote>
<p>A String property name <code>P</code> is an array index if and only if <code>ToString(ToUint32(P))</code> is equal to <code>P</code> and <code>ToUint32(P)</code> is not equal to 2^32^-1.</p>
</blockquote>
<p>This operation can be implemented in JavaScript as follows:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">toUint32</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">)))</span> <span class="o">%</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">isArrayIndex</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">numericKey</span> <span class="o">=</span> <span class="nx">toUint32</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">String</span><span class="p">(</span><span class="nx">numericKey</span><span class="p">)</span> <span class="o">==</span> <span class="nx">key</span> <span class="o">&amp;&amp;</span> <span class="nx">numericKey</span> <span class="o">&lt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
  </figure>
</div>
<p>The <code>toUint32()</code> function converts a given value into an unsigned 32-bit integer using an algorithm described in the specification. The <code>isArrayIndex()</code> function first converts the key into a uint32 and then performs the comparisons to determine if the key is an array index or not. With these utility functions available, you can start to implement an object that will mimic a built-in array.</p>
<h3 id="increasing-length-when-adding-new-elements">Increasing length when Adding New Elements<a href="#increasing-length-when-adding-new-elements" class="anchor" aria-hidden="true">#</a> </h3>
<p>You might have noticed that both array behaviors I described rely on the assignment of a property. That means you really only need to use the <code>set</code> proxy trap to accomplish both behaviors. To get started, here&rsquo;s an example that implements the first of the two behaviors by incrementing the <code>length</code> property when an array index larger than <code>length - 1</code> is used:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">toUint32</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">)))</span> <span class="o">%</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">isArrayIndex</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">numericKey</span> <span class="o">=</span> <span class="nx">toUint32</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">String</span><span class="p">(</span><span class="nx">numericKey</span><span class="p">)</span> <span class="o">==</span> <span class="nx">key</span> <span class="o">&amp;&amp;</span> <span class="nx">numericKey</span> <span class="o">&lt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">createMyArray</span><span class="p">(</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="nx">length</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">set</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">currentLength</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="s2">&#34;length&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// the special case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">isArrayIndex</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="kd">let</span> <span class="nx">numericKey</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="nx">numericKey</span> <span class="o">&gt;=</span> <span class="nx">currentLength</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="s2">&#34;length&#34;</span><span class="p">,</span> <span class="nx">numericKey</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// always do this regardless of key type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">colors</span> <span class="o">=</span> <span class="nx">createMyArray</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;red&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;green&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;blue&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;black&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span> <span class="c1">// &#34;black&#34;
</span></span></span></code></pre></div>
  </figure>
</div>
<p>This example uses the <code>set</code> proxy trap to intercept the setting of an array index. If the key is an array index, then it is converted into a number because keys are always passed as strings. Next, if that numeric value is greater than or equal to the current <code>length</code> property, then the <code>length</code> property is updated to be one more than the numeric key (setting an item in position 3 means the <code>length</code> must be 4). After that, the default behavior for setting a property is used via <code>Reflect.set()</code>, since you do want the property to receive the value as specified.</p>
<p>The initial custom array is created by calling <code>createMyArray()</code> with a <code>length</code> of 3 and the values for those three items are added immediately afterward. The <code>length</code> property correctly remains 3 until the value <code>&quot;black&quot;</code> is assigned to position 3. At that point, <code>length</code> is set to 4.</p>
<p>With the first behavior working, it&rsquo;s time to move on to the second.</p>
<h3 id="deleting-elements-on-reducing-length">Deleting Elements on Reducing length<a href="#deleting-elements-on-reducing-length" class="anchor" aria-hidden="true">#</a> </h3>
<p>The first array behavior to mimic is used only when an array index is greater than or equal to the <code>length</code> property. The second behavior does the opposite and removes array items when the <code>length</code> property is set to a smaller value than it previously contained. That involves not only changing the <code>length</code> property, but also deleting all items that might otherwise exist. For instance, if an array with a <code>length</code> of 4 has <code>length</code> set to 2, the items in positions 2 and 3 are deleted. You can accomplish this inside the <code>set</code> proxy trap alongside the first behavior. Here&rsquo;s the previous example again, with an updated <code>createMyArray</code> method:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">toUint32</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">)))</span> <span class="o">%</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">isArrayIndex</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">numericKey</span> <span class="o">=</span> <span class="nx">toUint32</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">String</span><span class="p">(</span><span class="nx">numericKey</span><span class="p">)</span> <span class="o">==</span> <span class="nx">key</span> <span class="o">&amp;&amp;</span> <span class="nx">numericKey</span> <span class="o">&lt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">createMyArray</span><span class="p">(</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="nx">length</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">set</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">currentLength</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="s2">&#34;length&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// the special case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">isArrayIndex</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="kd">let</span> <span class="nx">numericKey</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="nx">numericKey</span> <span class="o">&gt;=</span> <span class="nx">currentLength</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="s2">&#34;length&#34;</span><span class="p">,</span> <span class="nx">numericKey</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">===</span> <span class="s2">&#34;length&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="nx">currentLength</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">currentLength</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">value</span><span class="p">;</span> <span class="nx">index</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="nx">Reflect</span><span class="p">.</span><span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// always do this regardless of key type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">colors</span> <span class="o">=</span> <span class="nx">createMyArray</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;red&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;green&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;blue&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;black&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// &#34;green&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// &#34;red&#34;
</span></span></span></code></pre></div>
  </figure>
</div>
<p>The <code>set</code> proxy trap in this code checks to see if <code>key</code> is <code>&quot;length&quot;</code> in order to adjust the rest of the object correctly. When that happens, the current length is first retrieved using <code>Reflect.get()</code> and compared against the new value. If the new value is less than the current length, then a <code>for</code> loop deletes all properties on the target that should no longer be available. The <code>for</code> loop goes backward from the current array length (<code>currentLength</code>) and deletes each property until it reaches the new array length (<code>value</code>).</p>
<p>This example adds four colors to <code>colors</code> and then sets the <code>length</code> property to 2. That effectively removes the items in positions 2 and 3, so they now return <code>undefined</code> when you attempt to access them. The <code>length</code> property is correctly set to 2 and the items in positions 0 and 1 are still accessible.</p>
<p>With both behaviors implemented, you can easily create an object that mimics the behavior of built-in arrays. But doing so with a function isn&rsquo;t as desirable as creating a class to encapsulate this behavior, so the next step is to implement this functionality as a class.</p>
<h3 id="implementing-the-myarray-class">Implementing the MyArray Class<a href="#implementing-the-myarray-class" class="anchor" aria-hidden="true">#</a> </h3>
<p>The simplest way to create a class that uses a proxy is to define the class as usual and then return a proxy from the constructor. That way, the object returned when a class is instantiated will be the proxy instead of the instance. (The instance is the value of <code>this</code> inside the constructor.) The instance becomes the target of the proxy and the proxy is returned as if it were the instance. The instance will be completely private and you won&rsquo;t be able to access it directly, though you&rsquo;ll be able to access it indirectly through the proxy.</p>
<p>Here&rsquo;s a simple example of returning a proxy from a class constructor:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Thing</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">{});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">myThing</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Thing</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">myThing</span> <span class="k">instanceof</span> <span class="nx">Thing</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
  </figure>
</div>
<p>In this example, the class <code>Thing</code> returns a proxy from its constructor. The proxy target is <code>this</code> and the proxy is returned from the constructor. That means <code>myThing</code> is actually a proxy even though it was created by calling the <code>Thing</code> constructor. Because proxies pass through their behavior to their targets, <code>myThing</code> is still considered an instance of <code>Thing</code>, making the proxy completely transparent to anyone using the <code>Thing</code> class.</p>
<p>With that in mind, creating a custom array class using a proxy in relatively straightforward. The code is mostly the same as the code in the &ldquo;Deleting Elements on Reducing Length&rdquo; section. The same proxy code is used, but this time, it&rsquo;s inside a class constructor. Here&rsquo;s the complete example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">toUint32</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="nx">value</span><span class="p">)))</span> <span class="o">%</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">isArrayIndex</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">let</span> <span class="nx">numericKey</span> <span class="o">=</span> <span class="nx">toUint32</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">String</span><span class="p">(</span><span class="nx">numericKey</span><span class="p">)</span> <span class="o">==</span> <span class="nx">key</span> <span class="o">&amp;&amp;</span> <span class="nx">numericKey</span> <span class="o">&lt;</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">MyArray</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">set</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">let</span> <span class="nx">currentLength</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="s2">&#34;length&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// the special case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">isArrayIndex</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="kd">let</span> <span class="nx">numericKey</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="nx">numericKey</span> <span class="o">&gt;=</span> <span class="nx">currentLength</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="s2">&#34;length&#34;</span><span class="p">,</span> <span class="nx">numericKey</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">===</span> <span class="s2">&#34;length&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&lt;</span> <span class="nx">currentLength</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">currentLength</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">value</span><span class="p">;</span> <span class="nx">index</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="nx">Reflect</span><span class="p">.</span><span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// always do this regardless of key type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">colors</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyArray</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span> <span class="k">instanceof</span> <span class="nx">MyArray</span><span class="p">);</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;red&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;green&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;blue&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;black&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span> <span class="c1">// undefined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// &#34;green&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// &#34;red&#34;
</span></span></span></code></pre></div>
  </figure>
</div>
<p>This code creates a <code>MyArray</code> class that returns a proxy from its constructor. The <code>length</code> property is added in the constructor (initialized to either the value that is passed in or to a default value of 0) and then a proxy is created and returned. This gives the <code>colors</code> variable the appearance of being just an instance of <code>MyArray</code> and implements both of the key array behaviors.</p>
<p>Although returning a proxy from a class constructor is easy, it does mean that a new proxy is created for every instance. There is, however, a way to have all instances share one proxy: you can use the proxy as a prototype.</p>
<h2 id="using-a-proxy-as-a-prototype">Using a Proxy as a Prototype<a href="#using-a-proxy-as-a-prototype" class="anchor" aria-hidden="true">#</a> </h2>
<p>Proxies can be used as prototypes, but doing so is a bit more involved than the previous examples in this chapter. When a proxy is a prototype, the proxy traps are only called when the default operation would normally continue on to the prototype, which does limit a proxy&rsquo;s capabilities as a prototype. Consider this example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">newTarget</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// never called
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">defineProperty</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// would cause an error if called
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">newTarget</span><span class="p">,</span> <span class="s2">&#34;name&#34;</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;newTarget&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newTarget</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;newTarget&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newTarget</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s2">&#34;name&#34;</span><span class="p">));</span> <span class="c1">// true
</span></span></span></code></pre></div>
  </figure>
</div>
<p>The <code>newTarget</code> object is created with a proxy as the prototype. Making <code>target</code> the proxy target effectively makes <code>target</code> the prototype of <code>newTarget</code> because the proxy is transparent. Now, proxy traps will only be called if an operation on <code>newTarget</code> would pass the operation through to happen on <code>target</code>.</p>
<p>The <code>Object.defineProperty()</code> method is called on <code>newTarget</code> to create an own property called <code>name</code>. Defining a property on an object isn&rsquo;t an operation that normally continues to the object&rsquo;s prototype, so the <code>defineProperty</code> trap on the proxy is never called and the <code>name</code> property is added to <code>newTarget</code> as an own property.</p>
<p>While proxies are severely limited when used as prototypes, there are a few traps that are still useful.</p>
<h3 id="using-the-get-trap-on-a-prototype">Using the <code>get</code> Trap on a Prototype<a href="#using-the-get-trap-on-a-prototype" class="anchor" aria-hidden="true">#</a> </h3>
<p>When the internal <code>[[Get]]</code> method is called to read a property, the operation looks for own properties first. If an own property with the given name isn&rsquo;t found, then the operation continues to the prototype and looks for a property there. The process continues until there are no further prototypes to check.</p>
<p>Thanks to that process, if you set up a <code>get</code> proxy trap, the trap will be called on a prototype whenever an own property of the given name doesn&rsquo;t exist. You can use the <code>get</code> trap to prevent unexpected behavior when accessing properties that you can&rsquo;t guarantee will exist. Just create an object that throws an error whenever you try to access a property that doesn&rsquo;t exist:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">thing</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">get</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">ReferenceError</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb"> doesn&#39;t exist`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">thing</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;thing&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">thing</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;thing&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// throw an error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">unknown</span> <span class="o">=</span> <span class="nx">thing</span><span class="p">.</span><span class="nx">unknown</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p>In this code, the <code>thing</code> object is created with a proxy as its prototype. The <code>get</code> trap throws an error when called to indicate that the given key doesn&rsquo;t exist on the <code>thing</code> object. When <code>thing.name</code> is read, the operation never calls the <code>get</code> trap on the prototype because the property exists on <code>thing</code>. The <code>get</code> trap is called only when the <code>thing.unknown</code> property, which doesn&rsquo;t exist, is accessed.</p>
<p>When the last line executes, <code>unknown</code> isn&rsquo;t an own property of <code>thing</code>, so the operation continues to the prototype. The <code>get</code> trap then throws an error. This type of behavior can be very useful in JavaScript, where unknown properties silently return <code>undefined</code> instead of throwing an error (as happens in other languages).</p>
<p>It&rsquo;s important to understand that in this example, <code>trapTarget</code> and <code>receiver</code> are different objects. When a proxy is used as a prototype, the <code>trapTarget</code> is the prototype object itself while the <code>receiver</code> is the instance object. In this case, that means <code>trapTarget</code> is equal to <code>target</code> and <code>receiver</code> is equal to <code>thing</code>. That allows you access both to the original target of the proxy and the object on which the operation is meant to take place.</p>
<h3 id="using-the-set-trap-on-a-prototype">Using the <code>set</code> Trap on a Prototype<a href="#using-the-set-trap-on-a-prototype" class="anchor" aria-hidden="true">#</a> </h3>
<p>The internal <code>[[Set]]</code> method also checks for own properties and then continues to the prototype if needed. When you assign a value to an object property, the value is assigned to the own property with the same name if it exists. If no own property with the given name exists, then the operation continues to the prototype. The tricky part is that even though the assignment operation continues to the prototype, assigning a value to that property will create a property on the instance (not the prototype) by default, regardless of whether a property of that name exists on the prototype.</p>
<p>To get a better idea of when the <code>set</code> trap will be called on a prototype and when it won&rsquo;t, consider the following example showing the default behavior:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">thing</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">set</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">thing</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s2">&#34;name&#34;</span><span class="p">));</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// triggers the `set` proxy trap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">thing</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;thing&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">thing</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;thing&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">thing</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="s2">&#34;name&#34;</span><span class="p">));</span> <span class="c1">// true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// does not trigger the `set` proxy trap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">thing</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;boo&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">thing</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// &#34;boo&#34;
</span></span></span></code></pre></div>
  </figure>
</div>
<p>In this example, <code>target</code> starts with no own properties. The <code>thing</code> object has a proxy as its prototype that defines a <code>set</code> trap to catch the creation of any new properties. When <code>thing.name</code> is assigned <code>&quot;thing&quot;</code> as its value, the <code>set</code> proxy trap is called because <code>thing</code> doesn&rsquo;t have an own property called <code>name</code>. Inside the <code>set</code> trap, <code>trapTarget</code> is equal to <code>target</code> and <code>receiver</code> is equal to <code>thing</code>. The operation should ultimately create a new property on <code>thing</code>, and fortunately <code>Reflect.set()</code> implements this default behavior for you if you pass in <code>receiver</code> as the fourth argument.</p>
<p>Once the <code>name</code> property is created on <code>thing</code>, setting <code>thing.name</code> to a different value will no longer call the <code>set</code> proxy trap. At that point, <code>name</code> is an own property so the <code>[[Set]]</code> operation never continues on to the prototype.</p>
<h3 id="using-the-has-trap-on-a-prototype">Using the <code>has</code> Trap on a Prototype<a href="#using-the-has-trap-on-a-prototype" class="anchor" aria-hidden="true">#</a> </h3>
<p>Recall that the <code>has</code> trap intercepts the use of the <code>in</code> operator on objects. The <code>in</code> operator searches first for an object&rsquo;s own property with the given name. If an own property with that name doesn&rsquo;t exist, the operation continues to the prototype. If there&rsquo;s no own property on the prototype, then the search continues through the prototype chain until the own property is found or there are no more prototypes to search.</p>
<p>The <code>has</code> trap is therefore only called when the search reaches the proxy object in the prototype chain. When using a proxy as a prototype, that only happens when there&rsquo;s no own property of the given name. For example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">target</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">thing</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">has</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// triggers the `has` proxy trap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;name&#34;</span> <span class="k">in</span> <span class="nx">thing</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">thing</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&#34;thing&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// does not trigger the `has` proxy trap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;name&#34;</span> <span class="k">in</span> <span class="nx">thing</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
  </figure>
</div>
<p>This code creates a <code>has</code> proxy trap on the prototype of <code>thing</code>. The <code>has</code> trap isn&rsquo;t passed a <code>receiver</code> object like the <code>get</code> and <code>set</code> traps are because searching the prototype happens automatically when the <code>in</code> operator is used. Instead, the <code>has</code> trap must operate only on <code>trapTarget</code>, which is equal to <code>target</code>. The first time the <code>in</code> operator is used in this example, the <code>has</code> trap is called because the property <code>name</code> doesn&rsquo;t exist as an own property of <code>thing</code>. When <code>thing.name</code> is given a value and then the <code>in</code> operator is used again, the <code>has</code> trap isn&rsquo;t called because the operation stops after finding the own property <code>name</code> on <code>thing</code>.</p>
<p>The prototype examples to this point have centered around objects created using the <code>Object.create()</code> method. But if you want to create a class that has a proxy as a prototype, the process is a bit more involved.</p>
<h3 id="proxies-as-prototypes-on-classes">Proxies as Prototypes on Classes<a href="#proxies-as-prototypes-on-classes" class="anchor" aria-hidden="true">#</a> </h3>
<p>Classes cannot be directly modified to use a proxy as a prototype because their <code>prototype</code> property is non-writable. You can, however, use a bit of misdirection to create a class that has a proxy as its prototype by using inheritance. To start, you need to create an ECMAScript 5-style type definition using a constructor function. You can then overwrite the prototype to be a proxy. Here&rsquo;s an example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">NoSuchProperty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// empty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">NoSuchProperty</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">get</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">ReferenceError</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb"> doesn&#39;t exist`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">thing</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">NoSuchProperty</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// throws error due to `get` proxy trap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">thing</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p>The <code>NoSuchProperty</code> function represents the base from which the class will inherit. There are no restrictions on the <code>prototype</code> property of functions, so you can overwrite it with a proxy. The <code>get</code> trap is used to throw an error when the property doesn&rsquo;t exist. The <code>thing</code> object is created as an instance of <code>NoSuchProperty</code> and throws an error when the nonexistent <code>name</code> property is accessed.</p>
<p>The next step is to create a class that inherits from <code>NoSuchProperty</code>. You can simply use the <code>extends</code> syntax discussed in Chapter 9 to introduce the proxy into the class&rsquo; prototype chain, like this:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">NoSuchProperty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// empty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">NoSuchProperty</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">get</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">ReferenceError</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb"> doesn&#39;t exist`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Square</span> <span class="kr">extends</span> <span class="nx">NoSuchProperty</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">shape</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">area1</span> <span class="o">=</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">area1</span><span class="p">);</span> <span class="c1">// 12
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// throws an error because &#34;wdth&#34; doesn&#39;t exist
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">area2</span> <span class="o">=</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">wdth</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p>The <code>Square</code> class inherits from <code>NoSuchProperty</code> so the proxy is in the <code>Square</code> class&rsquo; prototype chain. The <code>shape</code> object is then created as a new instance of <code>Square</code> and has two own properties: <code>length</code> and <code>width</code>. Reading the values of those properties succeeds because the <code>get</code> proxy trap is never called. Only when a property that doesn&rsquo;t exist on <code>shape</code> is accessed (<code>shape.wdth</code>, an obvious typo) does the <code>get</code> proxy trap trigger and throw an error.</p>
<p>That proves the proxy is in the prototype chain of <code>shape</code>, but it might not be obvious that the proxy is not the direct prototype of <code>shape</code>. In fact, the proxy is a couple of steps up the prototype chain from <code>shape</code>. You can see this more clearly by slightly altering the preceding example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">NoSuchProperty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// empty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// store a reference to the proxy that will be the prototype
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">get</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">ReferenceError</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb"> doesn&#39;t exist`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">NoSuchProperty</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">proxy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Square</span> <span class="kr">extends</span> <span class="nx">NoSuchProperty</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">shape</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">shapeProto</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">shape</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">shapeProto</span> <span class="o">===</span> <span class="nx">proxy</span><span class="p">);</span> <span class="c1">// false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">secondLevelProto</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">shapeProto</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">secondLevelProto</span> <span class="o">===</span> <span class="nx">proxy</span><span class="p">);</span> <span class="c1">// true
</span></span></span></code></pre></div>
  </figure>
</div>
<p>This version of the code stores the proxy in a variable called <code>proxy</code> so it&rsquo;s easy to identify later. The prototype of <code>shape</code> is <code>Square.prototype</code>, which is not a proxy. But the prototype of <code>Square.prototype</code> is the proxy that was inherited from <code>NoSuchProperty</code>.</p>
<p>The inheritance adds another step in the prototype chain, and that matters because operations that might result in calling the <code>get</code> trap on <code>proxy</code> need to go through one extra step before getting there. If there&rsquo;s a property on <code>Square.prototype</code>, then that will prevent the <code>get</code> proxy trap from being called, as in this example:</p>



<div class="expressive-code">
  <figure class="frame not-content">
  <figcaption class="header">
    <span class="title"></span>
  </figcaption>
  <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">NoSuchProperty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// empty
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">NoSuchProperty</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="p">{},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">get</span><span class="p">(</span><span class="nx">trapTarget</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="k">new</span> <span class="nx">ReferenceError</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb"> doesn&#39;t exist`</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">Square</span> <span class="kr">extends</span> <span class="nx">NoSuchProperty</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">super</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">getArea</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">shape</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">area1</span> <span class="o">=</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">area1</span><span class="p">);</span> <span class="c1">// 12
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">let</span> <span class="nx">area2</span> <span class="o">=</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">getArea</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">area2</span><span class="p">);</span> <span class="c1">// 12
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// throws an error because &#34;wdth&#34; doesn&#39;t exist
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span> <span class="nx">area3</span> <span class="o">=</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">wdth</span><span class="p">;</span></span></span></code></pre></div>
  </figure>
</div>
<p>Here, the <code>Square</code> class has a <code>getArea()</code> method. The <code>getArea()</code> method is automatically added to <code>Square.prototype</code> so when <code>shape.getArea()</code> is called, the search for the method <code>getArea()</code> starts on the <code>shape</code> instance and then proceeds to its prototype. Because <code>getArea()</code> is found on the prototype, the search stops and the proxy is never called. That is actually the behavior you want in this situation, as you wouldn&rsquo;t want to incorrectly throw an error when <code>getArea()</code> was called.</p>
<p>Even though it takes a little bit of extra code to create a class with a proxy in its prototype chain, it can be worth the effort if you need such functionality.</p>
<h2 id="summary">Summary<a href="#summary" class="anchor" aria-hidden="true">#</a> </h2>
<p>Prior to ECMAScript 6, certain objects (such as arrays) displayed nonstandard behavior that developers couldn&rsquo;t replicate. Proxies change that. They let you define your own nonstandard behavior for several low-level JavaScript operations, so you can replicate all behaviors of built-in JavaScript objects through proxy traps. These traps are called behind the scenes when various operations take place, like a use of the <code>in</code> operator.</p>
<p>A reflection API was also introduced in ECMAScript 6 to allow developers to implement the default behavior for each proxy trap. Each proxy trap has a corresponding method of the same name on the <code>Reflect</code> object, another ECMAScript 6 addition. Using a combination of proxy traps and reflection API methods, it&rsquo;s possible to filter some operations to behave differently only in certain conditions while defaulting to the built-in behavior.</p>
<p>Revocable proxies are a special proxies that can be effectively disabled by using a <code>revoke()</code> function. The <code>revoke()</code> function terminates all functionality on the proxy, so any attempt to interact with the proxy&rsquo;s properties throws an error after <code>revoke()</code> is called. Revocable proxies are important for application security where third-party developers may need access to certain objects for a specified amount of time.</p>
<p>While using proxies directly is the most powerful use case, you can also use a proxy as the prototype for another object. In that case, you are severely limited in the number of proxy traps you can effectively use. Only the <code>get</code>, <code>set</code>, and <code>has</code> proxy traps will ever be called on a proxy when it&rsquo;s used as a prototype, making the set of use cases much smaller.</p>

			<div class="page-footer-meta d-flex flex-column flex-md-row justify-content-between">
				</div>
			<div class="page-nav d-flex flex-column flex-sm-row">
	
	<div class="card w-100">
			<div class="card-body d-flex">
				<div class="d-flex flex-column justify-content-center">
					<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-arrow-left" width="20" height="20" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
						<path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
						<path d="M5 12l14 0"></path>
						<path d="M5 12l6 6"></path>
						<path d="M5 12l6 -6"></path>
				 	</svg>
				</div>
				<div class="d-flex flex-column">
					<div class="text-body-secondary">Prev</div>
					<a href="/es6/11-promises/" class="stretched-link text-reset text-decoration-none">11 Promises and Asynchronous Programming</a>
				</div>
			</div>
		</div>
	<div class="m-2"></div>
	<div class="card text-end w-100">
			<div class="card-body d-flex justify-content-end">
				<div class="d-flex flex-column">
					<div class="text-body-secondary">Next</div>
					<a href="/es6/13-modules/" class="stretched-link text-reset text-decoration-none">13 Encapsulating Code With Modules</a>
				</div>
				<div class="d-flex flex-column justify-content-center">
					<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-arrow-right" width="20" height="20" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
						<path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
						<path d="M5 12l14 0"></path>
						<path d="M13 18l6 -6"></path>
						<path d="M13 6l6 6"></path>
					</svg>
				</div>
			</div>
		</div>
	</div>

			
		</main>
		
	</div>

      
      </div>
    </div>
    
    
    <footer class="footer text-muted">
  <div class="container-lg">
    <div class="row">
      <div class="col-lg-8 text-center text-lg-start">
        <ul class="list-inline">
          <li class="list-inline-item"><a class="text-muted" href="/privacy/">Privacy Policy</a></li>
        </ul>
      </div>
      <div class="col-lg-8 text-center text-lg-end">
        <ul class="list-inline">
          <li class="list-inline-item">Brought to you by <a class="text-muted" href="https://www.linkedin.com/in/snrakshith/">snrakshith</a></li>
        </ul>
      </div>
    </div>
  </div>
</footer>

    

<script async
  src="/js/app.1bc033eaaa1b81261bc59c2b90ab0e71c32562150e1fd35b692a8ed86d12ea64.js"
  integrity="sha256-G8Az6qobgSYbxZwrkKsOccMlYhUOH9NbaSqO2G0S6mQ=">
</script>





<script async
  src="/js/flexsearch.be33aab3067e96554f261851c25a593228b91154cd28ff5c7f8d52b2e7f306d2.js"
  integrity="sha256-vjOqswZ&#43;llVPJhhRwlpZMii5EVTNKP9cf41SsufzBtI=">
</script>
<script async
  src="/js/search-modal.97d606e77f08deeb37876860d99c8f6813ef29263e73b6435c252de6be98d55e.js"
  integrity="sha256-l9YG538I3us3h2hg2ZyPaBPvKSY&#43;c7ZDXCUt5r6Y1V4=">
</script>

    
  </body>
</html>